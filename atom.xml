<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Martin Li&#39;s Personal Website - 李杨的个人站点</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://luckymartinlee.github.io/"/>
  <updated>2020-12-26T07:16:17.449Z</updated>
  <id>http://luckymartinlee.github.io/</id>
  
  <author>
    <name>Martin Li</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java IO流详解</title>
    <link href="http://luckymartinlee.github.io/2020/03/14/java_1-5/"/>
    <id>http://luckymartinlee.github.io/2020/03/14/java_1-5/</id>
    <published>2020-03-14T06:16:21.000Z</published>
    <updated>2020-12-26T07:16:17.449Z</updated>
    
    <content type="html"><![CDATA[<p>##　IO流总览<br><img src="/post_imgs/java_1-5-1.png" alt=""></p><p><img src="/post_imgs/java_1_5_2.jpg" alt=""></p><p>以上两图即是 Java IO流的总体概览，由上图，我们可以看出</p><p>按照“流”的数据流向，可以将其化分为：输入流和输出流。<br>按照“流”中处理数据的单位，可以将其区分为：字节流和字符流。在java中，字节是占1个Byte，即8位；而字符是占2个Byte，即16位。而且，需要注意的是，java的字节是有符号类型，而字符是无符号类型！</p><p>字节流的抽象基类：<br>　　InputStream，OutputStream</p><p>字符流的抽象基类：<br>　　Reader，Writer</p><p>由这四个类派生出来的子类名称都是以其父类名作为子类名的后缀，如InputStream的子类FileInputStream，Reader的子类FileReader。</p><h2 id="字符流和字节流的区别"><a href="#字符流和字节流的区别" class="headerlink" title="字符流和字节流的区别"></a>字符流和字节流的区别</h2><p>字符流和字节流的使用非常相似，但是实际上字节流的操作不会经过缓冲区（内存）而是直接操作文本本身的，而字符流的操作会先经过缓冲区（内存）然后通过缓冲区再操作文件。</p><p>缓冲区就是一段特殊的内存区域，很多情况下当程序需要频繁地操作一个资源（如文件或数据库）则性能会很低，所以为了提升性能就可以将一部分数据暂时读写到缓存区，以后直接从此区域中读写数据即可，这样就显著提升了性。<br>对于 Java 字符流的操作都是在缓冲区操作的，所以如果我们想在字符流操作中主动将缓冲区刷新到文件则可以使用 flush() 方法操作。</p><p>多数情况下使用字节流会更好，因为大多数时候 IO 操作都是直接操作磁盘文件，所以这些流在传输时都是以字节的方式进行的（图片等也都是按字节存储的）<br>如果对于操作需要通过 IO 在内存中频繁处理字符串的情况使用字符流会好些，因为字符流具备缓冲区，提高了性能。</p><h2 id="字符流与字节流转换"><a href="#字符流与字节流转换" class="headerlink" title="字符流与字节流转换"></a>字符流与字节流转换</h2><p>OutputStreamWriter(OutStreamout):将字节流以字符流输出<br>InputStreamReader(InputStream in)：将字节流以字符流输入</p><p>可对读取到的字节数据经过指定编码转换成字符<br>可对读取到的字符数据经过指定编码转换成字节</p><h2 id="Java序列化"><a href="#Java序列化" class="headerlink" title="Java序列化"></a>Java序列化</h2><p>序列化就是一种用来处理对象流的机制，将对象的内容进行流化。可以对流化后的对象进行读写操作，可以将流化后的对象传输于网络之间。序列化是为了解决在对象流读写操作时所引发的问题<br>序列化的实现：将需要被序列化的类实现Serialize接口，没有需要实现的方法，此接口只是为了标注对象可被序列化的，然后使用一个输出流（如：FileOutputStream）来构造一个ObjectOutputStream(对象流)对象，再使用ObjectOutputStream对象的write(Object obj)方法就可以将参数obj的对象写出</p><h2 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h2><p>File类是对文件系统中文件以及文件夹进行封装的对象，可以通过对象的思想来操作文件和文件夹。 File类保存文件或目录的各种元数据信息，包括文件名、文件长度、最后修改时间、是否可读、获取当前文件的路径名，判断指定文件是否存在、获得当前目录中的文件列表，创建、删除文件和目录等方法。  </p><h2 id="RandomAccessFile类"><a href="#RandomAccessFile类" class="headerlink" title="RandomAccessFile类"></a>RandomAccessFile类</h2><p>该对象并不是流体系中的一员，其封装了字节流，同时还封装了一个缓冲区（字符数组），通过内部的指针来操作字符数组中的数据。 该对象特点：<br>该对象只能操作文件，所以构造函数接收两种类型的参数：a.字符串文件路径；b.File对象。<br>该对象既可以对文件进行读操作，也能进行写操作，在进行对象实例化时可指定操作模式(r,rw)<br>注意：该对象在实例化时，如果要操作的文件不存在，会自动创建；如果文件存在，写数据未指定位置，会从头开始写，即覆盖原有的内容。 可以用于多线程下载或多个线程同时写数据到文件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##　IO流总览&lt;br&gt;&lt;img src=&quot;/post_imgs/java_1-5-1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/post_imgs/java_1_5_2.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;以上两图即是 Java IO流的总体概览，
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luckymartinlee.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java http协议与网络基础一</title>
    <link href="http://luckymartinlee.github.io/2020/03/14/java_1-6/"/>
    <id>http://luckymartinlee.github.io/2020/03/14/java_1-6/</id>
    <published>2020-03-14T06:16:21.000Z</published>
    <updated>2020-12-27T01:22:25.804Z</updated>
    
    <content type="html"><![CDATA[<p>##　OSI 参考模型对比 TCP/IP 参考模型</p><p><img src="/post_imgs/java_1-6-1.gif" alt=""></p><p>OSI 参考模型 是 国际标准化组织ISO 提出的不基于具体机型、操作系统或公司的网络体系结构，称为开放系统互连参考模型，即OSI/RM（Open System Interconnection Reference Model），但其模型过于庞大、复杂招致了许多批评。与此相对，美国国防部提出了TCP/IP协议栈参考模型，简化了OSI参考模型，由于TCP/IP协议栈的简单，获得了广泛的应用，并成为后续因特网使用的参考模型。</p><h2 id="TCP-IP-参考模型-常见协议"><a href="#TCP-IP-参考模型-常见协议" class="headerlink" title="TCP/IP 参考模型 常见协议"></a>TCP/IP 参考模型 常见协议</h2><p><img src="/post_imgs/java_1-6-2.png" alt=""></p><p>此处重点说下 TCP 协议<br>TCP是面向连接的协议，因此每个TCP连接都有3个阶段：连接建立、数据传送和连接释放。连接建立经历三个步骤，通常称为“三次握手”</p><p>TCP三次握手过程<br><img src="/post_imgs/java_1-6-3.png" alt=""></p><p>1、 第一次握手（客户端发送请求）<br>客户机发送连接请求报文段到服务器，并进入SYN_SENT状态，等待服务器确认。发送连接请求报文段内容：SYN=1，seq=x；SYN=1意思是一个TCP的SYN标志位置为1的包，指明客户端打算连接的服务器的端口；seq=x表示客户端初始序号x，保存在包头的序列号（Sequence Number）字段里。</p><p>2、 第二次握手（服务端回传确认）<br>服务器收到客户端连接请求报文，如果同意建立连接，向客户机发回确认报文段（ACK）应答，并为该TCP连接分配TCP缓存和变量。服务器发回确认报文段内容：SYN=1，ACK=1，seq=y，ack=x+1；SYN标志位和ACK标志位均为1，同时将确认序号（Acknowledgement Number）设置为客户的ISN加1，即x+1；seq=y为服务端初始序号y。</p><p>3、 第三次握手（客户端回传确认）<br>客户机收到服务器的确认报文段后，向服务器给出确认报文段（ACK），并且也要给该连接分配缓存和变量。此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。客户端发回确认报文段内容：ACK=1，seq=x+1，ack=y+1；ACK=1为确认报文段；seq=x+1为客户端序号加1；ack=y+1,为服务器发来的ACK的初始序号字段+1。</p><p>注意：握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。</p><p>TCP四次挥手过程<br><img src="/post_imgs/java_1-6-4.png" alt=""><br>由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p><p>1、 TCP客户端发送一个FIN，用来关闭客户端到服务端的数据传送，客户端进入FIN_WAIT_1状态。发送报文段内容：<br>FIN=1，seq=u；<br>FIN=1表示请求切断连接；seq=u为客户端请求初始序号。</p><p>2、 服务端收到这个FIN，它发回一个ACK给客户端，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号；服务端进入CLOSE_WAIT状态。发送报文段内容：<br>ACK=1，seq=v，ack=u+1；<br>ACK=1为确认报文；seq=v为服务器确认初始序号；ack=u+1为客户端初始序号加1。</p><p>3、服务器关闭客户端的连接后，发送一个FIN给客户端，服务端进入LAST_ACK状态。发送报文段内容：<br>FIN=1，ACK=1，seq=w，ack=u+1；<br>FIN=1为请求切断连接，ACK=1为确认报文，seq=w为服务端请求切断初始序号。</p><p>4、 客户端收到FIN后，客户端进入TIME_WAIT状态，接着发回一个ACK报文给服务端确认，并将确认序号设置为收到序号加1，服务端进入CLOSED状态，完成四次挥手。发送报文内容：<br>ACK=1，seq=u+1，ack=w+1；<br>ACK=1为确认报文，seq=u+1为客户端初始序号加1，ack=w+1为服务器初始序号加1。</p><p>注意：为什么连接的时候是三次握手，关闭的时候却是四次挥手？<br>因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭socket，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文，我收到了”。只有等到服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送，故需要四步挥手。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##　OSI 参考模型对比 TCP/IP 参考模型&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/post_imgs/java_1-6-1.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;OSI 参考模型 是 国际标准化组织ISO 提出的不基于具体机型、操作系统或公司的网络体系结构，称为开放
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luckymartinlee.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java 性能优化的若干原则</title>
    <link href="http://luckymartinlee.github.io/2020/03/14/java_1-7/"/>
    <id>http://luckymartinlee.github.io/2020/03/14/java_1-7/</id>
    <published>2020-03-14T06:16:21.000Z</published>
    <updated>2020-12-26T02:41:21.435Z</updated>
    
    <content type="html"><![CDATA[<p>##　正确使用基本数据类型和其包装类类型</p><p>虽然包装类型和基本类型在使用过程中是可以相互转换，但它们两者所产生的内存区域是完全不同的，基本类型数据产生和处理都在栈中处理，而包装类型是对象，是在堆中产生实例。在集合类对象，有对象方面需要的处理适用包装类型，其他的情况，建议提倡使用基本类型。</p><h2 id="善用-ArrayList-amp-LinkedList"><a href="#善用-ArrayList-amp-LinkedList" class="headerlink" title="善用 ArrayList &amp; LinkedList"></a>善用 ArrayList &amp; LinkedList</h2><p>一个是线性表，一个是链表，一句话，随机查询尽量使用 ArrayList，ArrayList优于LinkedList，LinkedList还要移动指针，添加删除的操作LinkedList优于 ArrayList，ArrayList还要移动数据，不过这是理论性分析，事实未必如此，重要的是理解好数据结构。</p><h2 id="缓存经常使用的对象"><a href="#缓存经常使用的对象" class="headerlink" title="缓存经常使用的对象"></a>缓存经常使用的对象</h2><p>尽可能将经常使用的对象进行缓存，可以使用数组，或HashMap的容器来进行缓存，但这种方式可能导致系统占用过多的缓存，性能下降，推荐可以使用一些第三方的开源工具，如EhCache，Oscache进行缓存，他们基本都实现了FIFO/FLU等缓存算法。</p><h2 id="尽早释放无用对象的引用"><a href="#尽早释放无用对象的引用" class="headerlink" title="尽早释放无用对象的引用"></a>尽早释放无用对象的引用</h2><p>大部分情况下，方法局部引用变量所引用的对象会随着方法结束而变成垃圾，因此，大部分时候程序无需将局部引用变量显式设为null。<br>如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Public void <span class="function"><span class="title">doJob</span></span>()&#123; </span><br><span class="line">Object obj =new Object(); </span><br><span class="line">……  </span><br><span class="line">Obj=null;  // 没有必要</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面这个就没必要了，随着方法doJob()的执行完成，程序中obj引用变量的作用域会被gc回收。但是如果是改成下面：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void <span class="function"><span class="title">doJob</span></span>()&#123; </span><br><span class="line">Object obj =new Object(); </span><br><span class="line">……  </span><br><span class="line">Obj=null;  // 有必要</span><br><span class="line"></span><br><span class="line">//以下执行耗时，耗内存操作，或调用耗时，耗内存的方法  </span><br><span class="line">……  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这时候就有必要将obj赋值为null，可以尽早的释放对Object对象的引用。</p><h2 id="使用final修饰符"><a href="#使用final修饰符" class="headerlink" title="使用final修饰符"></a>使用final修饰符</h2><p>带有final修饰符的类是不可派生的。在Java核心API中，有许多应用 final的例子，例如java.lang.String。为String类指定final防止了使用者覆盖length()方法。另外，如果一个类是 final的，则该类所有方法都是final的。Java编译器会寻找机会内联（inline）所有的final方法（这和具体的编译器实现有关）。此举能够使性能平均提高50%。</p><h2 id="没有必要时请不用使用静态变量"><a href="#没有必要时请不用使用静态变量" class="headerlink" title="没有必要时请不用使用静态变量"></a>没有必要时请不用使用静态变量</h2><p>使用Java的开发者都知道，当某个对象被定义为stataic变量所引用，这个对象所占有的内存将不会被回收。有时，开发者会将经常调用的对象或者变量定义为static，以便提高程序的运行性能。因此，不是常用到的对象或者变量，不要定义为static类型的变量，尤其是静态类对象的定义，一定要仔细考虑是否有必要。<br>如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class X&#123;   </span><br><span class="line">    static Y a = new Y();   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>类X创建了，没有被回收的话，静态变量a一直占用内存。</p><h2 id="充分利用单例机制"><a href="#充分利用单例机制" class="headerlink" title="充分利用单例机制"></a>充分利用单例机制</h2><p>使用单例可以减少对资源的加载，缩短运行的时间，提高系统效率。但是，单例并不是所有地方都适用于。简单来说，单例可以适用于以下两个方面：<br>1、 控制资源的使用，通过线程同步来控制资源的并发访问<br>2、 控制实例的产生，以达到节约资源的目的</p><h2 id="在finally块中释放资源"><a href="#在finally块中释放资源" class="headerlink" title="在finally块中释放资源"></a>在finally块中释放资源</h2><p>程序中使用到的资源应当被释放，以避免资源泄漏。这最好在finally块中去做。不管程序执行的结果如何，finally块总是会执行的，以确保资源的正确关闭。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##　正确使用基本数据类型和其包装类类型&lt;/p&gt;
&lt;p&gt;虽然包装类型和基本类型在使用过程中是可以相互转换，但它们两者所产生的内存区域是完全不同的，基本类型数据产生和处理都在栈中处理，而包装类型是对象，是在堆中产生实例。在集合类对象，有对象方面需要的处理适用包装类型，其他的情
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luckymartinlee.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java 内存模型和参数优化</title>
    <link href="http://luckymartinlee.github.io/2020/03/11/java_1-3/"/>
    <id>http://luckymartinlee.github.io/2020/03/11/java_1-3/</id>
    <published>2020-03-11T13:46:24.000Z</published>
    <updated>2020-12-26T01:01:16.047Z</updated>
    
    <content type="html"><![CDATA[<p>##　Java程序执行过程</p><p>1、 第一步，Java源代码文件(.java后缀)会被Java编译器编译为字节码文件(.class后缀)<br>2、 第二步，由JVM中的类加载器加载各个类的字节码文件，加载完毕之后，交由JVM执行引擎执行<br>3、 第三步，在程序执行过程中，JVM会用一段空间来存储程序执行期间需要用到的数据和相关信息，这段空间一般被称作为Runtime Data Area（运行时数据区），也就是我们常说的JVM内存<br>4、 因此，在Java中我们常常说到的内存管理就是针对这段空间进行管理（如何分配和回收内存空间）</p><h2 id="JVM-内存模型"><a href="#JVM-内存模型" class="headerlink" title="JVM 内存模型"></a>JVM 内存模型</h2><p><img src="/post_imgs/java_1_3_1.jpg" alt=""></p><p>上图中可以看出，JVM的内存空间分为3大部分，分别是堆内存、方法区和栈内存。其中栈内存可以再细分为java虚拟机栈和本地方法栈。堆内存可以划分为新生代和老年代。新生代中还可以再次划分为Eden区、From Survivor区和To Survivor区。划分出来的各个区，分别保存不同的数据</p><p><img src="/post_imgs/java_1_3_2.jpg" alt=""></p><p>堆内存： 用来存储对象本身的以及数组，是JVM内存模型中最大的一块区域，被所有线程共享，是在JVM启动时候进行创建的。几乎所有的对象的空间分配都是在堆内存上进行分配的。</p><p>考虑到JVM的内存回收机制，堆内存可以划分为新生代和老年代两个区域（默认新生代与老年代的空间大小为1：2）。新生代可以再划分为Eden区、From Survivor区和To Survivor区（三者比例为8：1：1）。几乎所有的新对象的创建都是在Eden区进行的。在垃圾回收（GC）过程中，Eden中的活跃对象会被转移到Survivor区，当再到达一定的年龄（经历过的Minor GC的次数），会被转移到老年代中。</p><p>堆可以处于物理上不连续的内存空间中，但是需要满足逻辑上的连续。在实现时，可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的</p><p>方法区：存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等。（注：在方法区中有一个非常重要的部分就是运行时常量池，它是每一个类或接口的常量池的运行时表示形式，在类和接口被加载到JVM后，对应的运行时常量池就被创建出来。当然并非Class文件常量池中的内容才能进入运行时常量池，在运行期间也可将新的常量放入运行时常量池中，比如String的intern方法。）<br>方法区也叫作永久代，也是被所有的线程共享的。</p><p>JDK1.7中，已经把放在永久代的字符串常量池移到堆中。JDK1.8撤销永久代，引入元空间。</p><p>方法区不需要连续的内存，可以选择固定大小或者可扩展。并且还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是有必要的。当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。</p><p>程序计数器：用于标识当前线程执行的字节码文件的行号指示器。多线程情况下，每个线程都具有各自独立的程序计数器，所以该区域是非线程共享的内存区域。它是CPU中的寄存器，它保存的是程序当前执行的指令的地址（也可以说保存下一条指令的所在存储单元的地址），当CPU需要执行指令时，需要从程序计数器中得到当前需要执行的指令所在存储单元的地址，然后根据得到的地址获取到指令，在得到指令之后，程序计数器便自动加1或者根据转移指针得到下一条指令的地址，如此循环，直至执行完所有的指令；（注：JVM中的程序计数器并不像汇编语言中的程序计数器一样是物理概念上的CPU寄存器，但是逻辑作用上是等同的，在JVM中多线程是通过线程轮流切换来获得CPU执行时间的，在任一具体时刻，一个CPU的内核只会执行一条线程中的指令，为了能够使得每个线程都在线程切换后能够恢复在切换之前的程序执行位置，每个线程都需要有自己独立的程序计数器，并且不能互相被干扰，否则就会影响到程序的正常执行次序。因此，可以这么说，程序计数器是每个线程所私有的）</p><p>当执行java方法时候，计数器中保存的是字节码文件的行号；当执行Native方法时，计数器的值为空。</p><p>Java栈：也叫作虚拟机栈，Java栈是Java方法执行的内存模型，Java栈中存放的是一个个的栈帧，每个栈帧（包括：局部变量表、操作数栈、运行时常量池（在下文中提到的方法区内）的引用、方法返回地址和一些额外的附加信息）对应一个被调用的方法，当线程执行一个方法时，就会随之创建一个对应的栈帧，并将建立的栈帧压栈。当方法执行完毕之后，便会将栈帧出栈（如果方法methodOne方法调用了methodTwo，那么methodOne就会先入栈创建一个栈桢，接着methodTwo再入栈成为栈顶(假设没有其他的方法执行)，methodTwo执行完先出栈，接着methodOne执行完出栈）。由于每个线程正在执行的方法可能不同，因此每个线程都会有一个自己的Java栈，互不干扰。</p><p>局部变量表中，可以存放的数据有8种基本数据类型（boolean，byte，char，short，int，float，long，double），对象引用和returnAddress类型。其中long和double因为是64位，会占用两个局部变量的空间。</p><p>在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度（比如递归调用的时候），将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常。</p><p>本地方法栈：Java栈是为执行Java方法服务的，而本地方法栈则是为执行本地方法（Native Method）服务的。它也是线程私有的内存区域，与java栈比较相似，不同之处在于该区域主要是保存Native方法相关的数据。Native方法是非Java语言编写的方法。</p><p>与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。</p><p>举例说明一下各个内存区域中保存的信息<br><img src="/post_imgs/java_1_3_4.jpg" alt=""></p><p>上面的代码中：<br>1、 堆中进行对象的空间分配，比如Hashtable对象和String对象。<br>2、 方法区中保存类信息（TestJVM），方法（put方法，print方法，test方法）和静态变量（NUM）<br>3、 java栈中保存对象引用（score）</p><h2 id="JVM内存参数设置"><a href="#JVM内存参数设置" class="headerlink" title="JVM内存参数设置"></a>JVM内存参数设置</h2><p><img src="/post_imgs/java_1_3_3.jpg" alt=""></p><p>1、 新生代分三个区，一个Eden区，两个Survivor区（from和to区），可以通过-XXSurvivorRatio调整比例<br>作用：默认-XX:SurvivorRatio＝8，表示Survivor区与Eden区的大小比值是1:1:8，在MinorGC过程，如果survivor空间不够大，不能够存储所有的从eden空间和from suvivor空间复制过来活动对象，溢出的对象会被复制到old代，溢出迁移到old代，会导致old代的空间快速增长</p><p>2、 大部分对象在先在Eden区中申请内存。<br>作用：可以通过设置-XX:PreTenureSizeThreShold大小，令大于这个值的对象直接保存到老年代，避免在Eden区与Survivor区之间频繁地通过复制算法回收内存</p><p>3、 当Eden区满时，无法为新的对象分配内存时，会进行Minor GC对其回收无用对象占用的内存，如果还有存活对象，则将存活的对象复制到Survivor From区（两个中Survivor对称）；然后从Eden区存活下来的对象，就会被复制到From，当这个From区满时，此区的存活对象将被复制到To区，接下来Eden区存活下来的对象就会被复制到To区，经历一定的次数Minor GC后，还存活的对象，将被复制“老年代(Tenured)”。<br>作用：Minor默认15次，可通过-MaxTenuringThreshold参数调整新生代回收次数，防止对象过早进入老年代，降低老年代溢出的可能性</p><p>4、新生代和老年代的默认比例为1:2，即新生代占堆内存的1/3，老年代占2/3，可调整-XX:NewRatio的大小设置年轻和年老的比例。<br>作用：默认-XX:NewRatio＝2，即young:tenured＝1:2，适当调整新生代大小，可以一定层度上较少Full GC出现的概率</p><p>其他参数：</p><p>-Xms and -Xmx (or: -XX:InitialHeapSize and -XX:MaxHeapSize)指定JVM的初始和最大堆内存大小，两值可以设置相同，以避免每次垃圾回收完成后JVM重新分配内存。</p><p>-Xmn<br>设置新生代大小。<br>整个堆大小 = 新生代大小 + 老年代大小 + 持久代大小<br>所以增大新生代后，将会减小老年代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。</p><p>-Xss<br>设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。</p><p>-XX:+HeapDumpOnOutOfMemoryError and -XX:HeapDumpPath<br>让JVM在发生内存溢出时自动的生成堆内存快照（堆内存快照文件有可能很庞大，推荐将堆内存快照生成路径指定到一个拥有足够磁盘空间的地方。）</p><p>-XX:OnOutOfMemoryError<br>当内存溢发生时，我们甚至可以可以执行一些指令，比如发个E-mail通知管理员或者执行一些清理工作（$ java -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tmp/heapdump.hprof -XX:OnOutOfMemoryError =”sh ~/cleanup.sh” MyApp）</p><p>-XX:PermSize and -XX:MaxPermSize<br>设置永久代大小的初始值和最大值（默认：最小值为物理内存的1/64，最大值为物理内存的1/16，永久代在堆内存中是一块独立的区域，这里设置的永久代大小并不会被包括在使用参数-XX:MaxHeapSize 设置的堆内存大小中）</p><p>-XX:PretenureSizeThreshold<br>令大于这个设置值的对象直接在老年代分配。这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制</p><p>总结：<br>JVM内存的系统级的调优主要的目的是减少Minor GC的频率和Full GC的次数，过多的Minor GC和Full GC是会占用很多的系统资源，影响系统的吞吐量。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##　Java程序执行过程&lt;/p&gt;
&lt;p&gt;1、 第一步，Java源代码文件(.java后缀)会被Java编译器编译为字节码文件(.class后缀)&lt;br&gt;2、 第二步，由JVM中的类加载器加载各个类的字节码文件，加载完毕之后，交由JVM执行引擎执行&lt;br&gt;3、 第三步，在程
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luckymartinlee.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java 反射 Reflect</title>
    <link href="http://luckymartinlee.github.io/2019/09/21/java_1-4/"/>
    <id>http://luckymartinlee.github.io/2019/09/21/java_1-4/</id>
    <published>2019-09-21T06:33:32.000Z</published>
    <updated>2020-12-16T03:46:35.614Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Class-类"><a href="#Class-类" class="headerlink" title="Class 类"></a>Class 类</h2><p>面向对象的世界里，万事万物都是对象，类也是对象。在 Java 中，除 静态成员 和 普通数据类型 不是对象，其他皆为对象。<br>其中定义的各种类，是 java.lang.Class 类的实例对象</p><h2 id="类对象的表示"><a href="#类对象的表示" class="headerlink" title="类对象的表示"></a>类对象的表示</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 创建一个 Foo 类的实例对象 foo1</span><br><span class="line">        Foo foo1 = new Foo(); // foo1 是 Foo 类的实例对象</span><br><span class="line">        // 万事万物皆是对象， Foo 类本身也是对象，它是 Class 类的实例对象</span><br><span class="line">        // 所有的类都是 Class 类的实例对象， 这个实例对象有三种表示方式</span><br><span class="line"></span><br><span class="line">        // 方式一, 通过类的静态成员变量 class，每个类都包含这个变量</span><br><span class="line">        Class c1 = Foo.class;</span><br><span class="line"></span><br><span class="line">        // 方式二, 通过类的实例对象的 getClass 方法</span><br><span class="line">        Class c2 = foo1.getClass();</span><br><span class="line"></span><br><span class="line">        // 方式三, 通过类的全称(包含包名)获取</span><br><span class="line">        Class c3 = Class.forName(<span class="string">"com.test.Foo"</span>);</span><br><span class="line"></span><br><span class="line">        // c1,c2,c3 表示了 Foo 类的类类型 (class <span class="built_in">type</span>), 且一个类只可能是 Class 类的一个类类型，</span><br><span class="line">        // 即是 一个类的类类型 是唯一的， 所以 以上三者是相等的</span><br><span class="line">        bool b1 = c1 == c2; // <span class="literal">true</span></span><br><span class="line">        bool b2 = c2 == c3; // <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        // 通过类的类类型，就可以去创建该类的实例对象，</span><br><span class="line">        // 需要注意，该类需要定义一个无参构造函数，且生成的实例对象需要强制类型转换</span><br><span class="line">        Foo foo2 = (Foo)c3.newInstance()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Foo &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="动态加载类与静态加载类"><a href="#动态加载类与静态加载类" class="headerlink" title="动态加载类与静态加载类"></a>动态加载类与静态加载类</h2><p>静态加载类: 编译时刻加载的类就是静态加载类，new 类名 出来的就是静态加载类，编译时刻就需要加载可能使用的所有的类。<br>动态加载类: 运行时刻加载的类就是动态加载类，看下面的例子<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 定义借口，同意标准</span><br><span class="line">interface Animalale &#123;</span><br><span class="line">    public void run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义类， 实现统一标准</span><br><span class="line">class Dog implements Animalale &#123;</span><br><span class="line">    public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">        System.out.println(<span class="string">"dog running."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 动态加载类， 运行时刻加载</span><br><span class="line">            Class c1 = Class.forName[args[0]]</span><br><span class="line">            // 通过类的类类型，去创建实例对象，</span><br><span class="line">            Animalale animal = (Animalale) c1.newInstance();</span><br><span class="line">            animal.run();</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 命令行输入</span><br><span class="line">java <span class="built_in">test</span> Dog</span><br><span class="line">// 输出</span><br><span class="line">dog running.</span><br></pre></td></tr></table></figure></p><p>上面的代码编译后，如有新的动物加入，只需要新写一个类实现 Animal 接口，编译这个新的类即可，原来的代码不需要改动。开发过程中，功能性的类都可以通过这种动态加载方式实现。</p><h2 id="数据类型的类类型"><a href="#数据类型的类类型" class="headerlink" title="数据类型的类类型"></a>数据类型的类类型</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//  void 关键字 和 基本数据类型 都有类类型</span><br><span class="line">Class c1 = int.class;</span><br><span class="line">Class c2 = String.class;</span><br><span class="line">Class c3 = double.class; // double 数据类型的类类型</span><br><span class="line">Class c4 = Double.class; // Double 类的类类型</span><br><span class="line">Class c5 = void.class;</span><br><span class="line">// 注意此处的 c3 ！= c4,</span><br></pre></td></tr></table></figure><h2 id="Class-类的常用函数"><a href="#Class-类的常用函数" class="headerlink" title="Class 类的常用函数"></a>Class 类的常用函数</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 获取类的成员方法信息</span><br><span class="line"> * @param obj  类的实例对象</span><br><span class="line"> */</span><br><span class="line">public static void printClassMethodMessage(Object obj)&#123;</span><br><span class="line">    // 获取类信息，首先需要获得类类型</span><br><span class="line">    Class c = obj.getClass();// 传递的是哪个子类的实例对象，获取的就是该子类的类类型</span><br><span class="line">    // 获取类名(包含包名)</span><br><span class="line">    System.out.println(<span class="string">"类名称:"</span>+c.getName());</span><br><span class="line">    // 获取类名(不包含包名)</span><br><span class="line">    // System.out.println(<span class="string">"类名称:"</span>+c.getSimpleName());</span><br><span class="line">    /*</span><br><span class="line">     * Method 类，所有成员方法都是  Method 类的实例对象</span><br><span class="line">     * getMethods() // 获取所有 public 类型的成员方法，包括父类继承过来的方法</span><br><span class="line">     * getDeclaredMethods() // 获取该类所有自己的声明的成员方法，包括public, private等，不论访问权限</span><br><span class="line">     */</span><br><span class="line">    Method[] ms = c.getMethods();</span><br><span class="line">    <span class="keyword">for</span>(int i = 0; i &lt; ms.length;i++)&#123;</span><br><span class="line">        // 获取返回值类型的类类型</span><br><span class="line">        Class returnType = ms[i].getReturnType();</span><br><span class="line">        System.out.print(returnType.getName()+<span class="string">" "</span>);</span><br><span class="line">        // 获取方法名称</span><br><span class="line">        System.out.print(ms[i].getName()+<span class="string">"("</span>);</span><br><span class="line">        // 获取参数类型的类类型 数组</span><br><span class="line">        Class[] paramTypes = ms[i].getParameterTypes();</span><br><span class="line">        <span class="keyword">for</span> (Class class1 : paramTypes) &#123;</span><br><span class="line">            System.out.print(class1.getName()+<span class="string">","</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">")"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 获取类的成员变量信息</span><br><span class="line"> * @param obj 类的实例对象</span><br><span class="line"> */</span><br><span class="line">public static void printFieldMessage(Object obj) &#123;</span><br><span class="line">    Class c = obj.getClass();</span><br><span class="line">    /*</span><br><span class="line">     * 类的成员变量也是对象, 是 java.lang.reflect.Field的对象</span><br><span class="line">     * getFields() // 获取所有 public 类型的成员变量，包括父类继承过来的</span><br><span class="line">     * getDeclaredFields() // 获取该类所有自己的声明的成员变量，不论访问权限</span><br><span class="line">     */</span><br><span class="line">    //Field[] fs = c.getFields();</span><br><span class="line">    Field[] fs = c.getDeclaredFields();</span><br><span class="line">    <span class="keyword">for</span> (Field field : fs) &#123;</span><br><span class="line">        // 获取成员变量类型的类类型</span><br><span class="line">        Class fieldType = field.getType();</span><br><span class="line">        // 获取成员变量类型的名字</span><br><span class="line">        String typeName = fieldType.getName();</span><br><span class="line">         // 获取成员变量的名字</span><br><span class="line">        String fieldName = field.getName();</span><br><span class="line">        System.out.println(typeName+<span class="string">" "</span>+fieldName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 获取类的构造函数信息</span><br><span class="line"> * @param obj 类的实例对象</span><br><span class="line"> */</span><br><span class="line">public static void printConMessage(Object obj)&#123;</span><br><span class="line">    Class c = obj.getClass();</span><br><span class="line">    /*</span><br><span class="line">     * 构造函数也是对象，是java.lang.Constructor的实例对象，它封装的了构造函数的信息</span><br><span class="line">     * getConstructors() // 获取所有 public 类型的构造函数</span><br><span class="line">     * getDeclaredConstructors() // 获取该类所有自己的声明的构造函数，不论访问权限</span><br><span class="line">     */</span><br><span class="line">    //Constructor[] cs = c.getConstructors();</span><br><span class="line">    Constructor[] cs = c.getDeclaredConstructors();</span><br><span class="line">    <span class="keyword">for</span> (Constructor constructor : cs) &#123;</span><br><span class="line">        // 获取构造函数名字</span><br><span class="line">        System.out.print(constructor.getName()+<span class="string">"("</span>);</span><br><span class="line">        // 获取构造函数 参数类型的类类型 数组</span><br><span class="line">        Class[] paramTypes = constructor.getParameterTypes();</span><br><span class="line">        <span class="keyword">for</span> (Class class1 : paramTypes) &#123;</span><br><span class="line">            System.out.print(class1.getName()+<span class="string">","</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">")"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法反射基本操作"><a href="#方法反射基本操作" class="headerlink" title="方法反射基本操作"></a>方法反射基本操作</h2><p>通过 Method.invoke(实例对象,[参数列表]) 进行 方法反射操作<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">public class MethodDemo1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">       // 获取 <span class="built_in">print</span>(int,int)方法，先获取类类型</span><br><span class="line">        A a1 = new A();</span><br><span class="line">        Class c = a1.getClass();</span><br><span class="line">        /*</span><br><span class="line">         * 获取方法，由方法名和参数列表唯一决定一个方法  </span><br><span class="line">         * getMethod() // 获取所有 public 类型的成员方法</span><br><span class="line">         * getDelcaredMethod() // 获取该类所有自己的声明的成员方法，不论访问权限</span><br><span class="line">         */</span><br><span class="line">        try &#123;</span><br><span class="line">            // 两种方式获取方法对象，效果一样</span><br><span class="line">            //Method m =  c.getMethod(<span class="string">"print"</span>, new Class[]&#123;int.class,int.class&#125;);</span><br><span class="line">            Method m = c.getMethod(<span class="string">"print"</span>, int.class,int.class);</span><br><span class="line">            </span><br><span class="line">            // 方法反射操作</span><br><span class="line">            // 下面两个参数传递方式，效果一样, o 就是 <span class="built_in">print</span> 方法的返回值，如没有返回值, o 就是 null </span><br><span class="line">            //Object o = m.invoke(a1,new Object[]&#123;10,20&#125;);</span><br><span class="line">            Object o = m.invoke(a1, 10,20);</span><br><span class="line">            上面通过方法反射操作和 通过 类的实例对象 直接调用，效果一样</span><br><span class="line">            //a1.print(10, 20);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"=================="</span>);</span><br><span class="line">            // 获取参数为 String 类型的 <span class="built_in">print</span>(String,String)</span><br><span class="line">            //Method m1 =  c.getMethod(<span class="string">"print"</span>, new Class[]&#123;String.class,String.class&#125;);</span><br><span class="line">             Method m1 = c.getMethod(<span class="string">"print"</span>,String.class,String.class);</span><br><span class="line">             //a1.print(<span class="string">"hello"</span>, <span class="string">"WORLD"</span>);</span><br><span class="line">             o = m1.invoke(a1, <span class="string">"hello"</span>,<span class="string">"WORLD"</span>);</span><br><span class="line">             System.out.println(<span class="string">"==================="</span>);</span><br><span class="line">             // 获取 无参数的 <span class="built_in">print</span>(String,String)</span><br><span class="line">             // Method m2 = c.getMethod(<span class="string">"print"</span>, new Class[]&#123;&#125;);</span><br><span class="line">             Method m2 = c.getMethod(<span class="string">"print"</span>);</span><br><span class="line">             // 两种调用方式，效果一样</span><br><span class="line">             // m2.invoke(a1, new Object[]&#123;&#125;);</span><br><span class="line">             m2.invoke(a1);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class A&#123;</span><br><span class="line">    public void <span class="function"><span class="title">print</span></span>()&#123;</span><br><span class="line">        System.out.println(<span class="string">"helloworld"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    public void <span class="built_in">print</span>(int a,int b)&#123;</span><br><span class="line">        System.out.println(a+b);</span><br><span class="line">    &#125;</span><br><span class="line">    public void <span class="built_in">print</span>(String a,String b)&#123;</span><br><span class="line">        System.out.println(a.toUpperCase()+<span class="string">","</span>+b.toLowerCase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="深入理解-Java-泛型"><a href="#深入理解-Java-泛型" class="headerlink" title="深入理解 Java 泛型"></a>深入理解 Java 泛型</h2><p>看下面实例<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ArrayList list = new ArrayList();</span><br><span class="line">    </span><br><span class="line">    ArrayList&lt;String&gt; list1 = new ArrayList&lt;String&gt;();</span><br><span class="line">    list1.add(<span class="string">"hello"</span>);</span><br><span class="line">    //list1.add(20); // 编译出错, 不能向 String 集合中加入 整型数据</span><br><span class="line">    Class c1 = list.getClass();</span><br><span class="line">    Class c2 = list1.getClass();</span><br><span class="line">    System.out.println(c1 == c2); // 返回结果: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    // 上面说明， 编译之后的集合的泛型是去泛型化的，</span><br><span class="line">    // 集合的泛型，目的是防止输入错误，也就是泛型只在编译阶段有效，</span><br><span class="line">    // 编译之后就无效了</span><br><span class="line">    // 而反射是在 运行时刻加载，通过反射，我们可以绕过泛型的编译限制，如下</span><br><span class="line">    try &#123;</span><br><span class="line">        Method m = c2.getMethod(<span class="string">"add"</span>, Object.class);</span><br><span class="line">        m.invoke(list1, 20); // 泛型绕过编译，绕过泛型，加入集合</span><br><span class="line">        System.out.println(list1.size());</span><br><span class="line">        System.out.println(list1);</span><br><span class="line"></span><br><span class="line">        // 注意此刻 不能 foreach 遍历，遍历报错，类型不对</span><br><span class="line">        /*</span><br><span class="line">        <span class="keyword">for</span> (String string : list1) &#123;</span><br><span class="line">            System.out.println(string);</span><br><span class="line">        &#125;</span><br><span class="line">        */</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Class-类&quot;&gt;&lt;a href=&quot;#Class-类&quot; class=&quot;headerlink&quot; title=&quot;Class 类&quot;&gt;&lt;/a&gt;Class 类&lt;/h2&gt;&lt;p&gt;面向对象的世界里，万事万物都是对象，类也是对象。在 Java 中，除 静态成员 和 普通数据类型 不
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luckymartinlee.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Spark 算子详解</title>
    <link href="http://luckymartinlee.github.io/2019/05/10/spark_1-2/"/>
    <id>http://luckymartinlee.github.io/2019/05/10/spark_1-2/</id>
    <published>2019-05-10T10:13:12.000Z</published>
    <updated>2020-12-09T08:49:01.150Z</updated>
    
    <content type="html"><![CDATA[<h2 id="算子分类"><a href="#算子分类" class="headerlink" title="算子分类"></a>算子分类</h2><p>1、 Transformation算子(转换算子)，此类算子操作是延迟计算的，即是将要从一个RDD转换成另一个RDD的操作，但不是马上执行，并不触发提交Job作业，需要等到有Action操作的时候才会真正触发运算。<br>根据操作数据类型的不同，可细分为 Value数据类型的Transformation算子 和 Key-Value数据类型的Transfromation算子<br>2、Action算子(行动算子), 这类算子会触发 SparkContext 提交Job作业，并将数据输出 Spark系统。</p><h2 id="重难-Transformation算子"><a href="#重难-Transformation算子" class="headerlink" title="重难 Transformation算子"></a>重难 Transformation算子</h2><p>glom<br>该函数是将RDD中每一个分区中各个元素合并成一个Array，这样每一个分区就只有一个数组元素<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val a = sc.parallelize(1 to 9, 3)</span><br><span class="line">a.glom.collect</span><br><span class="line">//输出</span><br><span class="line">res66: Array[Array[Int]] = Array(Array(1, 2, 3), Array(4, 5, 6), Array(7, 8, 9))</span><br></pre></td></tr></table></figure></p><p>mapPartitions(function)<br>与 map 类似，但函数单独在 RDD 的每个分区上运行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">val list = List(1, 2, 3, 4, 5, 6)</span><br><span class="line">sc.parallelize(list, 3).mapPartitions(iterator =&gt; &#123;</span><br><span class="line">  val buffer = new ListBuffer[Int]</span><br><span class="line">  <span class="keyword">while</span> (iterator.hasNext) &#123;</span><br><span class="line">    buffer.append(iterator.next() * 100)</span><br><span class="line">  &#125;</span><br><span class="line">  buffer.toIterator</span><br><span class="line">&#125;).foreach(println)</span><br><span class="line">//输出结果</span><br><span class="line">100 200 300 400 500 600</span><br></pre></td></tr></table></figure></p><p>join<br>在一个(K, V)和(K, W)类型的RDD 上调用时，返回一个(K, (V, W)) pairs 的 RDD，等价于内连接操作(不含 V或W 为空的)。<br>执行外连接，可以使用：<br>leftOuterJoin (不含 W 为空)<br>rightOuterJoin  (不含 W 为空)<br>fullOuterJoin (包含V 和 W 为空)</p><p>sample<br>数据采样。有三个可选参数：设置是否放回 (withReplacement)、采样的百分比 (fraction,小于等于1)、随机数生成器的种子 (seed)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val list = List(1, 2, 3, 4, 5, 6)</span><br><span class="line">sc.parallelize(list).sample(withReplacement = <span class="literal">false</span>, fraction = 0.5).foreach(println)</span><br><span class="line">//输出结果随机</span><br></pre></td></tr></table></figure></p><p>groupByKey<br>按照键进行分组,在一个 (K, V) pair 的 dataset 上调用时，返回一个 (K, Iterable<v>)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val list = List((<span class="string">"hadoop"</span>, 2), (<span class="string">"spark"</span>, 3), (<span class="string">"spark"</span>, 5), (<span class="string">"storm"</span>, 6), (<span class="string">"hadoop"</span>, 2))</span><br><span class="line">sc.parallelize(list).groupByKey().map(x =&gt; (x._1, x._2.toList)).foreach(println)</span><br><span class="line">//输出：</span><br><span class="line">(spark,List(3, 5))</span><br><span class="line">(hadoop,List(2, 2))</span><br><span class="line">(storm,List(6))</span><br></pre></td></tr></table></figure></v></p><p>cogroup<br>先同一个 (K, V) RDD 中的元素先按照 key 进行分组，然后再对不同 RDD 中的元素按照 key 进行分组<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">val list01 = List((1, <span class="string">"a"</span>),(1, <span class="string">"a"</span>), (2, <span class="string">"b"</span>), (3, <span class="string">"e"</span>))</span><br><span class="line">val list02 = List((1, <span class="string">"A"</span>), (2, <span class="string">"B"</span>), (3, <span class="string">"E"</span>))</span><br><span class="line">val list03 = List((1, <span class="string">"[ab]"</span>), (2, <span class="string">"[bB]"</span>), (3, <span class="string">"eE"</span>),(3, <span class="string">"eE"</span>))</span><br><span class="line">sc.parallelize(list01).cogroup(sc.parallelize(list02),sc.parallelize(list03)).foreach(println)</span><br><span class="line">// 输出</span><br><span class="line">(1,(CompactBuffer(a, a),CompactBuffer(A),CompactBuffer([ab])))</span><br><span class="line">(3,(CompactBuffer(e),CompactBuffer(E),CompactBuffer(eE, eE)))</span><br><span class="line">(2,(CompactBuffer(b),CompactBuffer(B),CompactBuffer([bB]))</span><br></pre></td></tr></table></figure></p><p>reduceByKey<br>按照键进行归约操作<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val list = List((<span class="string">"hadoop"</span>, 2), (<span class="string">"spark"</span>, 3), (<span class="string">"spark"</span>, 5), (<span class="string">"storm"</span>, 6), (<span class="string">"hadoop"</span>, 2))</span><br><span class="line">sc.parallelize(list).reduceByKey(_ + _).foreach(println)</span><br><span class="line">//输出</span><br><span class="line">(spark,8)</span><br><span class="line">(hadoop,4)</span><br><span class="line">(storm,6)</span><br></pre></td></tr></table></figure></p><p>sortBy(function) &amp; sortByKey<br>按照键进行排序，需要 collect 等action算子后才是有序的<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val list01 = List((100, <span class="string">"hadoop"</span>), (90, <span class="string">"spark"</span>), (120, <span class="string">"storm"</span>))</span><br><span class="line">sc.parallelize(list01).sortByKey(ascending = <span class="literal">false</span>).collect.foreach(println)</span><br><span class="line">// 输出</span><br><span class="line">(120,storm)</span><br><span class="line">(100,hadoop)</span><br><span class="line">(90,spark)</span><br></pre></td></tr></table></figure></p><p>按照指定function进行排序,需要 collect 等action算子后才是有序的<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val list02 = List((<span class="string">"hadoop"</span>,100), (<span class="string">"spark"</span>,90), (<span class="string">"storm"</span>,120))</span><br><span class="line">sc.parallelize(list02).sortBy(x=&gt;x._2,ascending=<span class="literal">false</span>).collect.foreach(println)</span><br><span class="line">// 输出</span><br><span class="line">(storm,120)</span><br><span class="line">(hadoop,100)</span><br><span class="line">(spark,90)</span><br></pre></td></tr></table></figure></p><p>aggregateByKey(zeroValue)(seqOp, combOp, [numPartitions])<br>当针对(K，V)对的数据集时，返回（K，U）对的数据集，先对分区内执行seqOp函数，zeroValue 聚合每个键的值，再对分区间执行combOp函数。与groupByKey 类似，reduce 任务的数量可通过第二个参数 numPartitions 进行配置。示例如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 为了清晰，以下所有参数均使用具名传参</span><br><span class="line">val list = List((<span class="string">"hadoop"</span>, 3), (<span class="string">"hadoop"</span>, 2), (<span class="string">"spark"</span>, 4), (<span class="string">"spark"</span>, 3), (<span class="string">"storm"</span>, 6), (<span class="string">"storm"</span>, 8))</span><br><span class="line">sc.parallelize(list,numSlices = 2).aggregateByKey(zeroValue = 0,numPartitions = 3)(</span><br><span class="line">      seqOp = math.max(_, _),</span><br><span class="line">      combOp = _ + _</span><br><span class="line">    ).collect.foreach(println)</span><br><span class="line">//输出结果：</span><br><span class="line">(hadoop,3)</span><br><span class="line">(storm,8)</span><br><span class="line">(spark,7)</span><br></pre></td></tr></table></figure></p><p>这里使用了 numSlices = 2 指定 aggregateByKey 父操作 parallelize 的分区数量为 2，其执行流程如下：<br><img src="/post_imgs/spark_1.png" alt=""></p><p>基于同样的执行流程，如果 numSlices = 1，则意味着只有输入一个分区，则其最后一步 combOp 相当于是无效的，执行结果为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(hadoop,3)</span><br><span class="line">(storm,8)</span><br><span class="line">(spark,4)</span><br></pre></td></tr></table></figure></p><p>同样的，如果每个单词对一个分区，即 numSlices = 6，此时相当于求和操作，执行结果为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(hadoop,5)</span><br><span class="line">(storm,14)</span><br><span class="line">(spark,7)</span><br></pre></td></tr></table></figure></p><p>aggregateByKey(zeroValue = 0,numPartitions = 3) 的第二个参数 numPartitions 决定的是输出 RDD 的分区数量，想要验证这个问题，可以对上面代码进行改写，使用 getNumPartitions 方法获取分区数量</p><p>combineByKey<a href="createCombiner:(V" target="_blank" rel="noopener">C</a> C,<br>　　mergeValue:(C, V) C,<br>　　mergeCombiners:(C, C) C,<br>　　partitioner:Partitioner,<br>　　mapSideCombine:Boolean=true,<br>　　serializer:Serializer=null<br>):RDD[(K,C)] </p><p>参数：createCombiner:V=&gt;C　　分组内的创建组合的函数。即是对读进来的数据进行初始化，其把当前的值作为参数，可以对该值做一些转换操作，转换为我们想要的数据格式<br>参数：mergeValue:(C,V)=&gt;C　　该函数主要是分区内的合并函数，作用在每一个分区内部。其功能主要是将V合并到之前(createCombiner)的元素C上,注意，这里的C指的是上一函数转换之后的数据格式，而这里的V指的是原始数据格式(上一函数为转换之前的)<br>参数：mergeCombiners:(C,C)=&gt;R　　该函数主要是进行分区之间合并，此时是将两个C合并为一个C，例如两个C:(Int)进行相加之后得到一个R:(Int)<br>参数：partitioner:自定义分区数，默认是hashPartitioner<br>参数：mapSideCombine:Boolean=true　　该参数是设置是否在map端进行combine操作，为了减小传输量，很多 combine 可以在 map 端先做，比如叠加，可以先在一个 partition 中把所有相同的 key 的 value 叠加，<br>参数：serializerClass： String = null，传输需要序列化，用户可以自定义序列化类</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">val ls3 = List((<span class="string">"001"</span>, <span class="string">"011"</span>), (<span class="string">"001"</span>,<span class="string">"012"</span>), (<span class="string">"002"</span>, <span class="string">"011"</span>), (<span class="string">"002"</span>, <span class="string">"013"</span>), (<span class="string">"002"</span>, <span class="string">"014"</span>))</span><br><span class="line">val d1 = sc.parallelize(ls3,2)</span><br><span class="line">d1.combineByKey(</span><br><span class="line">(v: (String)) =&gt; (v, 1),</span><br><span class="line">(acc: (String, Int),v: (String)) =&gt; (v+<span class="string">":"</span>+acc._1,acc._2+1),</span><br><span class="line">(p1:(String,Int),p2:(String,Int)) =&gt; (p1._1 + <span class="string">":"</span> + p2._1,p1._2 + p2._2)</span><br><span class="line">).collect().foreach(println)</span><br><span class="line">//输出</span><br><span class="line">(002,(014:013:011,3))</span><br><span class="line">(001,(012:011,2))</span><br></pre></td></tr></table></figure><h2 id="重难-Action算子"><a href="#重难-Action算子" class="headerlink" title="重难 Action算子"></a>重难 Action算子</h2><p>takeOrdered<br>按自然顺序（natural order）或自定义比较器（custom comparator）排序后返回前 n 个元素。需要注意的是 takeOrdered 使用隐式参数进行隐式转换，以下为其源码。所以在使用自定义排序时，需要继承 Ordering[T] 实现自定义比较器，然后将其作为隐式参数引入。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 继承 Ordering[T],实现自定义比较器，按照 value 值的长度进行排序</span><br><span class="line">class CustomOrdering extends Ordering[(Int, String)] &#123;</span><br><span class="line">    override def compare(x: (Int, String), y: (Int, String)): Int</span><br><span class="line">    = <span class="keyword">if</span> (x._2.length &gt; y._2.length) 1 <span class="keyword">else</span> -1</span><br><span class="line">&#125;</span><br><span class="line">val list = List((1, <span class="string">"hadoop"</span>), (1, <span class="string">"storm"</span>), (1, <span class="string">"azkaban"</span>), (1, <span class="string">"hive"</span>))</span><br><span class="line">//  引入隐式默认值</span><br><span class="line">implicit val implicitOrdering = new CustomOrdering</span><br><span class="line">sc.parallelize(list).takeOrdered(5)</span><br><span class="line">//输出</span><br><span class="line">Array((1,hive), (1,storm), (1,hadoop), (1,azkaban)</span><br></pre></td></tr></table></figure></p><p>take(n)<br>将RDD中的前 n 个元素作为一个 array 数组返回,是无序的。</p><p>first<br>返回 RDD 中的第一个元素，等价于 take(1)。</p><p>top（num：Int）（implicit ord：Ordering[T]）：Array[T]<br>默认返回最大的k个元素，可以定义排序的方式Ordering[T]。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class CustomOrdering extends Ordering[Int] &#123;</span><br><span class="line">    override def compare(x: Int, y: Int): Int</span><br><span class="line">    = <span class="keyword">if</span> (x &gt; y) -1 <span class="keyword">else</span> 1</span><br><span class="line">&#125;</span><br><span class="line">val list0 = List(3,5,1,6,2)</span><br><span class="line">//  引入隐式默认值</span><br><span class="line">implicit val implicitOrdering = new CustomOrdering</span><br><span class="line">sc.parallelize(list0).top(5)</span><br><span class="line">//输出</span><br><span class="line">Array(1,2,3,5,6)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;算子分类&quot;&gt;&lt;a href=&quot;#算子分类&quot; class=&quot;headerlink&quot; title=&quot;算子分类&quot;&gt;&lt;/a&gt;算子分类&lt;/h2&gt;&lt;p&gt;1、 Transformation算子(转换算子)，此类算子操作是延迟计算的，即是将要从一个RDD转换成另一个RDD的操作，
      
    
    </summary>
    
    
      <category term="大数据" scheme="http://luckymartinlee.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Spark" scheme="http://luckymartinlee.github.io/tags/Spark/"/>
    
  </entry>
  
  <entry>
    <title>压力测试工具 ab (apache bench) 使用</title>
    <link href="http://luckymartinlee.github.io/2019/05/10/ab_1-1/"/>
    <id>http://luckymartinlee.github.io/2019/05/10/ab_1-1/</id>
    <published>2019-05-10T10:13:12.000Z</published>
    <updated>2020-12-07T12:52:37.204Z</updated>
    
    <content type="html"><![CDATA[<h2 id="网络服务性能相关概念"><a href="#网络服务性能相关概念" class="headerlink" title="网络服务性能相关概念"></a>网络服务性能相关概念</h2><h3 id="服务器平均请求处理时间（Time-per-request-across-all-concurrent-requests）"><a href="#服务器平均请求处理时间（Time-per-request-across-all-concurrent-requests）" class="headerlink" title="服务器平均请求处理时间（Time per request: across all concurrent requests）"></a>服务器平均请求处理时间（Time per request: across all concurrent requests）</h3><p>即是在某个并发用户数下服务器处理一条请求的平均时间</p><p>服务器平均请求处理时间 = 处理完成所有请求数所花费的时间 / 总请求数<br>Time per request(across all concurrent requests) = Time taken for / testsComplete requests</p><h3 id="用户平均请求等待时间（Time-per-request）"><a href="#用户平均请求等待时间（Time-per-request）" class="headerlink" title="用户平均请求等待时间（Time per request）"></a>用户平均请求等待时间（Time per request）</h3><p>即是用户获得相应的平均等待时间</p><p>用户平均请求等待时间 = 处理完成所有请求数所花费的时间/ （总请求数 / 并发用户数），即<br>Time per request = Time taken for tests /（ Complete requests / Concurrency Level）</p><h3 id="吞吐率（Requests-per-second，QPS，RPS）"><a href="#吞吐率（Requests-per-second，QPS，RPS）" class="headerlink" title="吞吐率（Requests per second，QPS，RPS）"></a>吞吐率（Requests per second，QPS，RPS）</h3><p>即是在某个并发用户数下单位时间内处理的请求数,单位是reqs/s, 也是 “服务器平均请求处理时间” d的倒数。某个并发用户数下单位时间内能处理的最大请求数，称之为最大吞吐率。</p><p>吞吐率 = 总请求数 / 处理完成这些请求数所花费的时间<br>Request per second = Complete requests / Time taken for tests</p><h3 id="并发连接数（The-number-of-concurrent-connections）"><a href="#并发连接数（The-number-of-concurrent-connections）" class="headerlink" title="并发连接数（The number of concurrent connections）"></a>并发连接数（The number of concurrent connections）</h3><p>即是在某个时刻服务器所接受的请求数目，就是会话数量。</p><h3 id="并发用户数（The-number-of-concurrent-users，Concurrency-Level）"><a href="#并发用户数（The-number-of-concurrent-users，Concurrency-Level）" class="headerlink" title="并发用户数（The number of concurrent users，Concurrency Level）"></a>并发用户数（The number of concurrent users，Concurrency Level）</h3><p>即是指某个时刻使用系统的用户数(可能有一个用户有一个或者多个连接)。<br>要注意区分和并发连接数之间的区别，一个用户可能同时会产生多个会话，也即连接数。</p><p>总结:<br>如果要说QPS时，一定需要指明是多少并发用户数下的QPS，否则豪无意义。<br>因为单用户数的40QPS和20并发用户数下的40QPS是两个不同的概念，前者说明该服务可以在一秒内串行执行40个请求，而后者说明在并发20个请求的情况下，一秒内该应用能处理40个请求。<br>当QPS相同时，越大的并发用户数，说明了网站服务并发处理能力越好。<br>对于当前的web服务器，其处理单个用户的请求肯定戳戳有余，这个时候会存在资源浪费的情况（一方面该服务器可能有多个cpu，但是只处理单个进程，另一方面，在处理一个进程中，有些阶段可能是IO阶段，这个时候会造成CPU等待，但是有没有其他请求进程可以被处理）。<br>而当并发数设置的过大时，每秒钟都会有很多请求需要处理，会造成进程（线程）频繁切换，反正真正用于处理请求的时间变少，每秒能够处理的请求数反而变少，同时用户的请求等待时间也会变大，甚至超过用户的心理底线，等待时间过长。</p><p>所以在最小并发数和最大并发数之间，一定有一个最合适的并发数值，在并发数下，QPS能够达到最大。</p><p>但是，这个并发并非是一个最佳的并发，因为当QPS到达最大时的并发，可能已经造成用户的等待时间变得超过了其最优值，所以对于一个系统，其最佳的并发数，一定需要结合QPS，用户的等待时间来综合确定。</p><p>下面这张图是应用服务器关于并发用户数，QPS，用户平均等待时间的一张关系图，对于实际的系统，也应该是对于不同的并发数，进行多次测试，获取到这些数值后，画出这样一张图出来，以便于分析出系统的最佳并发用户数。</p><p><img src="/post_imgs/server_performance_relations_1.png" alt=""><br>响应时间关系图</p><h2 id="ab-简介和使用实例"><a href="#ab-简介和使用实例" class="headerlink" title="ab 简介和使用实例"></a>ab 简介和使用实例</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>ab全称为：apache bench<br>它是apache自带的压力测试工具。ab非常实用，它不仅可以对apache服务器进行网站访问压力测试，也可以对或其它类型的服务器进行压力测试。比如nginx、tomcat、IIS等。<br>我们可以直接安装apache的工具包httpd-tools。如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install httpd-tools</span><br></pre></td></tr></table></figure></p><p>使用ab –V命令检测是否安装成功。如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ab -V</span><br></pre></td></tr></table></figure></p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ab -n 100 -c 10 -H <span class="string">"token: fioj3iorm2aoi4ej"</span> -p /data/postdata.txt -T application/x-www-form-urlencoded <span class="string">"http://127.0.0.1/test"</span></span><br></pre></td></tr></table></figure><p>上面命令的含义是<br>设置请求header中参数token = fioj3iorm2aoi4ej，向 <a href="http://127.0.0.1/test" target="_blank" rel="noopener">http://127.0.0.1/test</a> 地址发送POST请求，POST表单数据存放在<br>本地文件/data/postdata.txt中，其content-type格式为  application/x-www-form-urlencoded，发送的并发请求数为 10，总请求数为 100。<br>成功后返回：<br><img src="/post_imgs/ab_result.png" alt=""></p><h3 id="测试结果含义"><a href="#测试结果含义" class="headerlink" title="测试结果含义"></a>测试结果含义</h3><table><thead><tr><th>返回值名称</th><th>含义</th></tr></thead><tbody><tr><td>Server Software</td><td>web服务器软件及版本</td></tr><tr><td>Server Hostname</td><td>表示请求的URL中的主机部分名称</td></tr><tr><td>Server Port</td><td>被测试的Web服务器的监听端口</td></tr><tr><td>Document Path</td><td>请求的页面路径</td></tr><tr><td>Document Length</td><td>页面大小</td></tr><tr><td>Concurrency Level</td><td>并发请求数</td></tr><tr><td>Time taken for tests</td><td>整个测试持续的时间,测试总共花费的时间</td></tr><tr><td>Complete requests</td><td>完成的请求数</td></tr><tr><td>Failed requests</td><td>失败的请求数，这里的失败是指请求的连接服务器、发送数据、接收数据等环节发生异常，以及无响应后超时的情况。对于超时时间的设置可以用ab的-t参数。如果接受到的http响应数据的头信息中含有2xx以外的状态码，则会在测试结果显示另一个名为“Non-2xx responses”的统计项，用于统计这部分请求数，这些请求并不算是失败的请求。</td></tr><tr><td>Write errors</td><td>写入错误</td></tr><tr><td>Total transferred</td><td>总共传输字节数,整个场景中的网络传输量,包含http的头信息等。使用ab的-v参数即可查看详细的http头信息。</td></tr><tr><td>HTML transferred</td><td>html字节数，整个场景中的HTML内容传输量。也就是减去了Total transferred中http响应数据中头信息的长度。</td></tr><tr><td><strong>Requests per second</strong></td><td>每秒处理的请求数，服务器的吞吐量，大家最关心的指标之一</td></tr><tr><td><strong>Time per request</strong></td><td>用户平均请求等待时间，大家最关心的指标之二</td></tr><tr><td><strong>Time per request</strong></td><td>服务器平均处理时间，大家最关心的指标之三</td></tr><tr><td>Transfer rate</td><td>平均传输速率（每秒收到的速率）平均每秒网络上的流量，可以很好的说明服务器在处理能力达到限制时，其出口带宽的需求量，也可以帮助排除是否存在网络流量过大导致响应时间延长的问题。</td></tr></tbody></table><p>下面段表示网络上消耗的时间的分解<br><img src="/post_imgs/ab_results_2.png" alt=""></p><p>下面这段是每个请求处理时间的分布情况，50%的处理时间在4930ms内，66%的处理时间在5008ms内…，重要的是看90%的处理时间。<br><img src="/post_imgs/ab_results_3.png" alt=""></p><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><p>压力测试需要当登录怎么办？<br>1、先用账户和密码在浏览器登录后，用开发者工具找到会话的Cookie值（Session ID）记下来。<br>2、使用下面命令传入Cookie值<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ab －n 100 －C key＝value http://127.0.0.1/<span class="built_in">test</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;网络服务性能相关概念&quot;&gt;&lt;a href=&quot;#网络服务性能相关概念&quot; class=&quot;headerlink&quot; title=&quot;网络服务性能相关概念&quot;&gt;&lt;/a&gt;网络服务性能相关概念&lt;/h2&gt;&lt;h3 id=&quot;服务器平均请求处理时间（Time-per-request-acro
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://luckymartinlee.github.io/tags/Linux/"/>
    
      <category term="Shell" scheme="http://luckymartinlee.github.io/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Java 集合基础</title>
    <link href="http://luckymartinlee.github.io/2019/04/21/java_1-2/"/>
    <id>http://luckymartinlee.github.io/2019/04/21/java_1-2/</id>
    <published>2019-04-21T07:02:38.000Z</published>
    <updated>2020-12-27T10:05:07.709Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>集合：集合是Java中提供的一种容器，可以用来存储多个数据。<br>集合和数组的区别：<br>（1）数组长度的是固定的，集合的长度是可变的。<br>（2）数组中存储的都是同一类型的元素。集合存储的都是对象，对象的类型可以不一致。<br>Java集合类主要由两个根接口Collection和Map派生出来的。Collection有三个子接口： List、Set、Queue（Java5新增的队列）。Java集合大致也可分成List、Set、Queue、Map四种接口体系，注意：Map不是Collection的子接口。<br>Collection接口：单列数据，定义了存取一组对象的方法的集合。<br>Map接口：双列数据，保存具有映射关系“key-value”对。</p><p><img src="/post_imgs/java_1-2-1.png" alt=""><br><img src="/post_imgs/java_1-2-2.png" alt=""></p><h2 id="Collection子接口：List接口"><a href="#Collection子接口：List接口" class="headerlink" title="Collection子接口：List接口"></a>Collection子接口：List接口</h2><p>List集合类中元素有序、且可重复，集合中的每个元素都有其对应的顺序索引。List集合默认按照元素的添加顺序设置元素的索引，可以通过索引（类似数组的下标）来访问指定位置的集合元素。</p><p>List接口的实现类主要有：ArrayList、LinkedList和Vector<br>ArrayList: 有序，元素可重复，线程不安全。它是一个动态数组，允许任何符合规则的元素插入包括null。 它能快速随机访问存储的元素，支持随机访问，查询速度快，增删元素慢。</p><p>LinkedList: 有序，元素可重复，线程不安全。可以根据索引访问集合元素外，LinkedList还实现了Deque接口。内部以链表的形式保存集合中的元素，所以随机访问集合中的元素性能较差，但在频繁的插入或删除元素时有较好的性能，线程不安全。</p><p>Vector: 有序，元素可重复，线程安全。大多数操作与ArrayList相同，区别之处在于Vector是线程安全的，属于强同步类。因此开销就比ArrayList要大，访问要慢。大多数清空下使用 ArrayList而不是Vector,因为同步完全可以由自己来控制。Vector每次扩容请求其大小的2倍空间，而ArrayList是1.5倍。Vector还有一个子类Stack。</p><h2 id="Collection子接口：Set接口"><a href="#Collection子接口：Set接口" class="headerlink" title="Collection子接口：Set接口"></a>Collection子接口：Set接口</h2><p>Set集合不允许包含相同的元素，如果试把两个相同的元素加入同一个Set集合中，则会添加操作失败。<br>Set集合判断两个对象是否相同是根据 equals() 方法，而不是使用 == 运算符。</p><p>HashSet： 无序，元素不可重复，线程不安全。按Hash算法来存储集合中的元素，因此具有很好的存取、查找、删除性能。<br>特点：<br>1、 不能保证元素的排列顺序<br>2、 HashSet不是线程安全的<br>3、 集合元素可以是null</p><p>HashSet集合判断两个元素相等的标准：两个对象通过 hashCode() 方法比较相等，并且两个对象的 equals() 方法返回值也相等。<br>对于存放在Set容器中的对象，对应的类一定要重写equals()和hashCode(Object obj)方法，以实现对象相等规则。</p><p>LinkedHashSet： 有序，元素不可重复，线程不安全。它是HashSet的子类，它也是根据元素的hashCode值来决定元素的存储位置。但它同时使用双向链表维护元素的次序，元素的顺序与添加顺序一致。<br>由于LinkedHashSet需要维护元素的插入顺序，因此性能略低于HashSet，但在迭代访问Set里的全部元素时有很好的性能。<br>LinkedHashSet不允许集合元素重复。</p><p>TreeSet： 有序（非输入顺序），元素不可重复，线程不安全。它是SortedSet接口的实现类，TreeSet可以确保集合元素处于排序状态。<br>如果试图把一个对象添加到TreeSet时，则该对象的类必须实现Comparable接口。<br>TreeSet底层使用红黑树结构存储数据元素。</p><p>TreeSet两种排序方法：自然排序和定制排序。默认情况下，TreeSet采用自然排序。</p><h2 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h2><p>Map与Collection并列存在。用于保存具有映射关系的数据:key-value<br>Map中的key和value都可以是任何引用类型的数据<br>Map中的key用Set来存放，不允许重复，即同一个Map对象所对应的类，须重写hashCode()和equals()方法</p><p>HashMap： 无序，元素不可重复，线程不安全。它是Map接口使用频率最高的实现类。允许使用null键和null值，与HashSet一样，不保证映射的顺序。<br>HashMap判断两个key相等的标准是：两个key通过equals() 方法返回true， hashCode值也相等。<br>HashMap判断两个value相等的标准是：两个value通过equals()方法返回true。<br>HashMap可以使用null值为key或value</p><p>LinkedHashMap： 有序，元素不可重复，线程不安全。它是 HashMap的子类，在HashMap存储结构的基础上，使用了一对双向链表来记录添加元素的顺序。 该链表负责维护Map的迭代顺序，与插入顺序一致，因此性能比HashMap低，但在迭代访问Map里的全部元素时有较好的性能。</p><p>TreeMap： 有序（非输入顺序），元素不可重复，线程不安全。它是根据key-value对进行排序。TreeMap可以保证所有的Key-Value对处于有序状态。底层采用红黑树的数据结构。<br>TreeMap也有两种排序方式，自然排序和定制排序。</p><p>Hashtable： 无序，元素不可重复，线程安全。<br>它不允许使用null作为key和value。<br>Hashtable实现原理和HashMap相同，底层都使用哈希表结构，查询速度快。<br>Hashtable和HashMap一样也不能保证其中Key-Value对的顺序。</p><p>Properties： 无序，元素不可重复，线程安全。它是Hashtable 的子类，该对象用于处理属性文件。<br>由于属性文件里的key、value都是字符串类型，所以Properties里的key和value都是字符串类型 。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;集合：集合是Java中提供的一种容器，可以用来存储多个数据。&lt;br&gt;集合和数组的区别：&lt;br&gt;（1）数组长度的是固定的，集合的长度是可变的。
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luckymartinlee.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java 线程</title>
    <link href="http://luckymartinlee.github.io/2019/04/11/java_1-1/"/>
    <id>http://luckymartinlee.github.io/2019/04/11/java_1-1/</id>
    <published>2019-04-11T02:13:32.000Z</published>
    <updated>2020-12-16T02:12:55.248Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><p>进程: 是程序的一次动态执行过程,经历代码加载，代码执行到执行完毕的一个完整的过程。多进程操作系统能同时达运行多个进程，由于 CPU 具备分时机制，所以每个进程都能循环获得自己的CPU 时间片。由于 CPU 执行速度非常快，使得所有程序好像是在同时运行一样。<br>线程: 是进程在执行过程中产生的多个更小的程序单元，这些更小的单元称为线程，这些线程可以同时存在，同时运行，一个进程可能包含多个同时执行的线程。<br>进程和线程一样，都是实现并发的一个基本单位。线程是比进程更小的执行单位，线程是进程的基础之上进行进一步的划分。</p><h2 id="Java-中线程实现"><a href="#Java-中线程实现" class="headerlink" title="Java 中线程实现"></a>Java 中线程实现</h2><p>Java 中实现多线程有三种手段，一种是继承 Thread 类，一种就是实现 Runnable 接口， 一种就是实现 Callable 接口</p><p>继承 Thread 类方式<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 继承Thread类，作为线程的实现类</span><br><span class="line">class ThreadExtd extends Thread&#123;  </span><br><span class="line">    private String name ;       // 表示线程的名称</span><br><span class="line">    public ThreadExtd(String name)&#123;</span><br><span class="line">        this.name = name ;      // 通过构造方法配置name属性</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void <span class="function"><span class="title">run</span></span>()&#123;  // 覆写run()方法，作为线程 的操作主体</span><br><span class="line">        <span class="keyword">for</span>(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">            System.out.println(name + <span class="string">"运行，i = "</span> + i) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实现 Runnable 接口方式<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public interface Runnable &#123;</span><br><span class="line">    public abstract void run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实现Runnable接口，作为线程的实现类</span><br><span class="line">class RunnableImpl implements Runnable&#123;</span><br><span class="line">    private String name ;       // 表示线程的名称</span><br><span class="line">    public RunnableImpl(String name)&#123;</span><br><span class="line">        this.name = name ;      // 通过构造方法配置name属性</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void <span class="function"><span class="title">run</span></span>()&#123;  // 覆写run()方法，作为线程 的操作主体</span><br><span class="line">        <span class="keyword">for</span>(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">            System.out.println(name + <span class="string">"运行，i = "</span> + i) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实现 Callable 接口方式<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public interface Callable&lt;V&gt; &#123;</span><br><span class="line">    V call() throws Exception;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实现 Callable 接口，作为线程的实现类 java.util.concurrent.Callable</span><br><span class="line"></span><br><span class="line">public class CallableImpl implements Callable&lt;String&gt; &#123;</span><br><span class="line"> </span><br><span class="line">    private String name ;       // 表示线程的名称</span><br><span class="line">    public CallableImpl(String name)&#123;</span><br><span class="line">        this.name = name ;      // 通过构造方法配置name属性</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String call() throws Exception &#123;  // 覆写 call() 方法，作为线程 的操作主体</span><br><span class="line">        <span class="keyword">for</span>(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">            System.out.println(name + <span class="string">"运行，i = "</span> + i) ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">return</span> this.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>三者区别与联系</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// FutureTask类实现了RunnableFuture接口，RunnableFuture继承了Future,实现了Runnable</span><br><span class="line">public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line">public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; &#123;</span><br><span class="line">    void run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    // 调用 Runnable 实现类</span><br><span class="line">    Runnable rallable = new RunnableImpl(<span class="string">"runnableImpl"</span>);</span><br><span class="line">    new Thread(rallable).start();</span><br><span class="line"></span><br><span class="line">    // 调用 Thread 继承类</span><br><span class="line">    Thread thread = new ThreadExtd(<span class="string">"threadExtd"</span>);</span><br><span class="line">    thread.start()</span><br><span class="line"></span><br><span class="line">    // 调用 Callable 实现类</span><br><span class="line">    Callable&lt;String&gt; callable = new CallableImpl(<span class="string">"callableImpl"</span>);</span><br><span class="line"></span><br><span class="line">    // Callable 实现类 线程运行方式一：通过Thread包装来直接执行</span><br><span class="line">    FutureTask&lt;String&gt; task = new FutureTask&lt;&gt;(callable);</span><br><span class="line">    // 创建线程</span><br><span class="line">    new Thread(task).start();</span><br><span class="line">    // 调用get()阻塞主线程，反之，线程不会阻塞</span><br><span class="line">    String result1 = task.get();</span><br><span class="line"></span><br><span class="line">    // Callable 实现类 线程运行方式二：利用ExecutorService的submit方法</span><br><span class="line">    ExecutorService executorService = Executors.newFixedThreadPool(10);</span><br><span class="line">    Future&lt;String&gt; future = executorService.submit(callable);</span><br><span class="line">    String result2 = future.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Callable 和 Runnable 的实现方式是实现其接口，支持多继承，但基本上用不到<br>Thread的实现方式是继承其类<br>Thread实现了Runnable接口并进行了扩展，Thread和Runnable的实质是继承关系，没有可比性。无论使用Runnable还是Thread，都需要new Thread，然后执行 start 方法。用法上，如果有复杂的线程操作需求，那就选择继承Thread，如果只是简单的执行一个任务，那就实现runnable。<br>实现Callable接口的任务线程能返回执行结果，Callable接口的call()方法允许抛出异常，而Runnable接口的run()方法的异常只能在内部消化，不能继续上抛。 Callable接口支持返回执行结果，此时需要调用FutureTask.get()方法实现，此方法会阻塞主线程直到获取结果，当不调用此方法时，主线程不会阻塞。</p><h2 id="Java-中线程-状态变化"><a href="#Java-中线程-状态变化" class="headerlink" title="Java 中线程 状态变化"></a>Java 中线程 状态变化</h2><p>创建状态<br>创建了一个线程对象后，新的线程对象便处于新建状态, 此时它已经有了相应的内存空间和其他资源<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread thread=new Thread();</span><br></pre></td></tr></table></figure></p><p>就绪状态<br>调用该线程的 start() 方法就可以启动线程。当线程启动时，线程进入就绪状态。此时，线程将进入线程队列排队，等待 CPU 服务，这表明它已经具备了运行条件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread.start();</span><br></pre></td></tr></table></figure></p><p>运行状态<br>线程队列中线程获得CPU资源时，线程就进入了运行状态, 此时，自动调用该线程对象的 run() 方法</p><p>阻塞状态<br>处于运行状态的线程在某些特殊情况下，如被人为挂起或需要执行耗时的输入/输出操作，会让 CPU 暂时中止自己的执行，此时，进入阻塞状态。或者，在运行状态下，调用了sleep(),suspend()(过时弃用),wait() 等方法，线程都将进入阻塞状态，发生阻塞时线程不能进入排队队列，只有当引起阻塞的原因被消除后，线程才可以转入就绪状态</p><p>死亡状态<br>线程调用 stop() 方法时或 run() 方法执行结束后，即处于死亡状态</p><h2 id="Java-中线程常用方法"><a href="#Java-中线程常用方法" class="headerlink" title="Java 中线程常用方法"></a>Java 中线程常用方法</h2><p>thread.sleep()<br>线程休眠: 线程暂缓执行，进入阻塞状态，等到预计时间再执行。<br>线程休眠会交出CPU，让CPU去执行其他的任务。但是有一点要非常注意，sleep方法不会释放锁，也就是说如果当前线程持有对某个对象的锁，则即使调用sleep方法，其他线程也无法访问这个对象</p><p>thread.join()<br>等待线程终止: 指在主线程中调用该方法时就会让主线程休眠，进入阻塞状态，让调用join()方法的线程先执行完毕后再开始执行主线程。</p><p>thread.yield()<br>线程让步: 暂停当前正在执行的线程对象，并执行其它线程<br>交出cpu, 但不释放锁，不进入阻塞状态，直接进入就绪状态</p><p>thread.interrupt()<br>设置中断标志: 只是改变中断状态而已，它不会中断一个正在运行的线程。具体来说就是，调用interrupt()方法只会给线程设置一个为true的中断标志，而设置之后，则根据线程当前状态进行不同的后续操作<br>1、如果线程的当前状态出于非阻塞状态，那么仅仅将线程的中断标志设置为true而已;<br>2、如果线程的当前状态出于阻塞状态，那么将在中断标志设置为true后，还会出现wait()、sleep()、join()方法之一引起的阻塞，那么会将线程的中断标志位重新设置为false，并抛出一个InterruptedException异常。<br>3、如果在中断时，线程正处于非阻塞状态，则将中断标志修改为true，而在此基础上，一旦进入阻塞状态，则按照阻塞状态的情况来进行处理。例如，一个线程在运行状态时，其中断标志设置为true之后，一旦线程调用了wait()、sleep()、join()方法中的一种，立马抛出一个InterruptedException异常，且中断标志被程序自动清除，重新设置为false。<br>调用Thread类的interrupted()方法，其本质只是设置该线程的中断标志，将中断标志设置为true，并根据线程状态决定是否抛出异常</p><p>object.wait()<br>线程等待: 让当前正在执行的线程进入线程阻塞状态的等待状态，该方法时用来将当前线程置入“预执行队列”中，并且调用wait()方法后，该线程在wait()方法所在的代码处停止执行，直到接到一些通知或被中断为止<br>1、wait()方法只能在同步代码块或同步方法中调用，故如果调用wait()方法时没有持有适当的锁时，就会抛出异常。<br>2、wait()方法执行后，当前线程释放锁并且与其他线程相互竞争重新获得锁。</p><p>object.notify()<br>线程唤醒: notify()方法要在同步代码块或同步方法中调用,用来通知那些等待该对象的对象锁的线程，对其调用wait()方法的对象发出通知让这些线程不再等待，继续执行.如果有多个线程都在等待，则由线程规划器随机挑选出一个呈wait状态的线程将其线程唤醒，继续执行该线程.<br>注意：调用notify()方法后，当前线程并不会马上释放该对象锁，要等到执行notify()方法的线程执行完才会释放对象锁</p><p>object.notifyAll()<br>线程唤醒: notifyAll()方法将同一对象锁的所有等待线程全部唤醒</p><p><img src="/post_imgs/java_1-1.png" alt=""><br>线程状态转换关系图</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;进程与线程&quot;&gt;&lt;a href=&quot;#进程与线程&quot; class=&quot;headerlink&quot; title=&quot;进程与线程&quot;&gt;&lt;/a&gt;进程与线程&lt;/h2&gt;&lt;p&gt;进程: 是程序的一次动态执行过程,经历代码加载，代码执行到执行完毕的一个完整的过程。多进程操作系统能同时达运行多个进
      
    
    </summary>
    
    
      <category term="Java" scheme="http://luckymartinlee.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Spark RDD的Stage划分</title>
    <link href="http://luckymartinlee.github.io/2018/10/13/spark_1-1/"/>
    <id>http://luckymartinlee.github.io/2018/10/13/spark_1-1/</id>
    <published>2018-10-13T02:23:11.000Z</published>
    <updated>2020-12-10T01:00:21.602Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是RDD"><a href="#什么是RDD" class="headerlink" title="什么是RDD"></a>什么是RDD</h2><p>RDD(resilient distributed dataset) 弹性分布式数据集,RDD表示一个不可变的、可分区的、支持并行计算的元素集合（类似于 Scala 中的不可变集合），RDD可以通过 HDFS、Scala集合、RDD转换、外部的数据集（支持InputFormat）获取，<br>并且 Spark 将 RDD 存储在内存中，可以非常高效的重复利用或者在某些计算节点故障时自动数据恢复。</p><h2 id="RDD依赖-lineage-血统"><a href="#RDD依赖-lineage-血统" class="headerlink" title="RDD依赖 - lineage(血统)"></a>RDD依赖 - lineage(血统)</h2><p>在对RDD应用转换操作时，产生的新 RDD 对旧 RDD 会有一种依赖关系称为 Lineage(血统).<br>Spark应用在计算时会根据 Lineage 逆向推导出所有Stage（阶段），每一个 Stage 的分区数量决定了任务的并行度，一个 Stage 实现任务的本地计算（大数据计算时网络传输时比较耗时的.</p><p>RDD 两种 Lineage 关系，宽窄依赖,v它们和Stage划分有极为紧密关系<br>窄依赖 (Narrow Dependency): 父RDD的一个分区对应一个子RDD的分区（1:1）或者多个父RDD的分区对应一个子RDD的分区（N：1）.</p><p>宽依赖 (Wide Dependency): 父RDD的一个分区对应多个子RDD的分区（1：N）.<br><img src="/post_imgs/spark_1_1.png" alt=""><br><img src="/post_imgs/spark_1_2.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是RDD&quot;&gt;&lt;a href=&quot;#什么是RDD&quot; class=&quot;headerlink&quot; title=&quot;什么是RDD&quot;&gt;&lt;/a&gt;什么是RDD&lt;/h2&gt;&lt;p&gt;RDD(resilient distributed dataset) 弹性分布式数据集,RDD表示一个不可变
      
    
    </summary>
    
    
      <category term="大数据" scheme="http://luckymartinlee.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Spark" scheme="http://luckymartinlee.github.io/tags/Spark/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ 基础</title>
    <link href="http://luckymartinlee.github.io/2018/08/03/RabbitMQ_1-1/"/>
    <id>http://luckymartinlee.github.io/2018/08/03/RabbitMQ_1-1/</id>
    <published>2018-08-03T12:23:21.000Z</published>
    <updated>2020-12-27T03:03:01.349Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>RabbitMQ 是一个开源的消息代理和队列服务器，用来通过普通协议在完全不同的应用之间共享数据，RabbitMQ是使用 Erlang语言来编写的，并且RabbitMQ是基于AMQP协议的。<br>AMQP，即Advanced Message Queuing Protocol，高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。消息中间件主要用于组件之间的解耦，消息的发送者无需知道消息使用者的存在，反之亦然。<br>AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。</p><p>RabbitMQ 特点:<br>1、开源、性能优秀、稳定性保障<br>2、 提供可靠性消息投递模式(confirm)、返回模式(return)<br>3、 与SpringAMQP完美的整合、API丰富<br>4、 集群模式丰富，表达式配置，HA模式，镜像队列模型<br>5、 保证数据不丢失的前提下做到高可靠性、可用性</p><p>RabbitMQ 架构:<br><img src="/post_imgs/rabbitmq_1-1-1.png" alt=""></p><p>RabbitMQ 消息传递流程:<br><img src="/post_imgs/rabbitmq_1-1-2.png" alt=""></p><p>其中，<br>Broker：消息队列服务进程，此进程包括两个部分：Exchange和Queue<br>Exchange：消息队列交换机，按一定的规则将消息路由转发到某个队列，对消息进行过虑。<br>Queue：消息队列，存储消息的队列，消息到达队列并转发给指定的<br>Producer：消息生产者，即生产方客户端，生产方客户端将消息发送<br>Consumer：消息消费者，即消费方客户端，接收MQ转发的消息。</p><p>生产者发送消息流程：<br>1、生产者和Broker建立TCP连接。<br>2、生产者和Broker建立通道。<br>3、生产者通过通道消息发送给Broker，由Exchange将消息进行转发。<br>4、Exchange将消息转发到指定的Queue（队列）</p><p>消费者接收消息流程：<br>1、消费者和Broker建立TCP连接<br>2、消费者和Broker建立通道<br>3、消费者监听指定的Queue（队列）<br>4、当有消息到达Queue时Broker默认将消息推送给消费者。<br>5、消费者接收到消息。<br>6、ack回复</p><h2 id="6种消息模型"><a href="#6种消息模型" class="headerlink" title="6种消息模型"></a>6种消息模型</h2><h3 id="基本消息模型"><a href="#基本消息模型" class="headerlink" title="基本消息模型"></a>基本消息模型</h3><p><img src="/post_imgs/rabbitmq_1-1-3.png" alt=""></p><p>一个生产者，一个消费者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">// 连接工具类</span><br><span class="line">public class ConnectionUtil &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 建立与RabbitMQ的连接</span><br><span class="line">     * @<span class="built_in">return</span></span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    public static Connection getConnection() throws Exception &#123;</span><br><span class="line">        //定义连接工厂</span><br><span class="line">        ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">        //设置服务地址</span><br><span class="line">        factory.setHost(<span class="string">"192.168.1.123"</span>);</span><br><span class="line">        //端口</span><br><span class="line">        factory.setPort(5672);</span><br><span class="line">        //设置账号信息，用户名、密码、vhost</span><br><span class="line">        factory.setVirtualHost(<span class="string">"/martin"</span>);//设置虚拟机，一个mq服务可以设置多个虚拟机，每个虚拟机就相当于一个独立的mq</span><br><span class="line">        factory.setUsername(<span class="string">"martin"</span>);</span><br><span class="line">        factory.setPassword(<span class="string">"123456"</span>);</span><br><span class="line">        // 通过工厂获取连接</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="built_in">return</span> connection;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 生产者</span><br><span class="line">public class Send &#123;</span><br><span class="line">    private final static String QUEUE_NAME = <span class="string">"simple_queue"</span>;</span><br><span class="line">    public static void main(String[] argv) throws Exception &#123;</span><br><span class="line">        // 1、获取到连接</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        // 2、从连接中创建通道，使用通道才能完成消息相关的操作</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        // 3、声明（创建）队列</span><br><span class="line">        //参数：String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments</span><br><span class="line">        /**</span><br><span class="line">         * 参数明细</span><br><span class="line">         * 1、queue 队列名称</span><br><span class="line">         * 2、durable 是否持久化，如果持久化，mq重启后队列还在</span><br><span class="line">         * 3、exclusive 是否独占连接，队列只允许在该连接中访问，如果connection连接关闭队列则自动删除,如果将此参数设置<span class="literal">true</span>可用于临时队列的创建</span><br><span class="line">         * 4、autoDelete 自动删除，队列不再使用时是否自动删除此队列，如果将此参数和exclusive参数设置为<span class="literal">true</span>就可以实现临时队列（队列不用了就自动删除）</span><br><span class="line">         * 5、arguments 参数，可以设置一个队列的扩展参数，比如：可设置存活时间</span><br><span class="line">         */</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, null);</span><br><span class="line">        // 4、消息内容</span><br><span class="line">        String message = <span class="string">"Hello World!"</span>;</span><br><span class="line">        // 向指定的队列中发送消息</span><br><span class="line">        //参数：String exchange, String routingKey, BasicProperties props, byte[] body</span><br><span class="line">        /**</span><br><span class="line">         * 参数明细：</span><br><span class="line">         * 1、exchange，交换机，如果不指定将使用mq的默认交换机（设置为<span class="string">""</span>）</span><br><span class="line">         * 2、routingKey，路由key，交换机根据路由key来将消息转发到指定的队列，如果使用默认交换机，routingKey设置为队列的名称</span><br><span class="line">         * 3、props，消息的属性</span><br><span class="line">         * 4、body，消息内容</span><br><span class="line">         */</span><br><span class="line">        channel.basicPublish(<span class="string">""</span>, QUEUE_NAME, null, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">" [x] Sent '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">        </span><br><span class="line">        //关闭通道和连接(资源关闭最好用try-catch-finally语句处理)</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 消费者</span><br><span class="line"></span><br><span class="line">public class Recv &#123;</span><br><span class="line">    private final static String QUEUE_NAME = <span class="string">"simple_queue"</span>;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] argv) throws Exception &#123;</span><br><span class="line">        // 获取到连接</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        //创建会话通道,生产者和mq服务所有通信都在channel通道中完成</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        // 声明队列</span><br><span class="line">        //参数：String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments</span><br><span class="line">        /**</span><br><span class="line">         * 参数明细</span><br><span class="line">         * 1、queue 队列名称</span><br><span class="line">         * 2、durable 是否持久化，如果持久化，mq重启后队列还在</span><br><span class="line">         * 3、exclusive 是否独占连接，队列只允许在该连接中访问，如果connection连接关闭队列则自动删除,如果将此参数设置<span class="literal">true</span>可用于临时队列的创建</span><br><span class="line">         * 4、autoDelete 自动删除，队列不再使用时是否自动删除此队列，如果将此参数和exclusive参数设置为<span class="literal">true</span>就可以实现临时队列（队列不用了就自动删除）</span><br><span class="line">         * 5、arguments 参数，可以设置一个队列的扩展参数，比如：可设置存活时间</span><br><span class="line">         */</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, null);</span><br><span class="line">        //实现消费方法</span><br><span class="line">        DefaultConsumer consumer = new DefaultConsumer(channel)&#123;</span><br><span class="line">            // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span><br><span class="line">            /**</span><br><span class="line">             * 当接收到消息后此方法将被调用</span><br><span class="line">             * @param consumerTag  消费者标签，用来标识消费者的，在监听队列时设置channel.basicConsume</span><br><span class="line">             * @param envelope 信封，通过envelope</span><br><span class="line">             * @param properties 消息属性</span><br><span class="line">             * @param body 消息内容</span><br><span class="line">             * @throws IOException</span><br><span class="line">             */</span><br><span class="line">            @Override</span><br><span class="line">            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;</span><br><span class="line">                //交换机</span><br><span class="line">                String exchange = envelope.getExchange();</span><br><span class="line">                //消息id，mq在channel中用来标识消息的id，可用于确认消息已接收</span><br><span class="line">                long deliveryTag = envelope.getDeliveryTag();</span><br><span class="line">                // body 即消息体</span><br><span class="line">                String msg = new String(body,<span class="string">"utf-8"</span>);</span><br><span class="line">                System.out.println(<span class="string">" [x] received : "</span> + msg + <span class="string">"!"</span>);</span><br><span class="line"></span><br><span class="line">                // 手动进行ACK</span><br><span class="line">                /*</span><br><span class="line">                 *  void basicAck(long deliveryTag, boolean multiple) throws IOException;</span><br><span class="line">                 *  deliveryTag:用来标识消息的id</span><br><span class="line">                 *  multiple：是否批量.<span class="literal">true</span>:将一次性ack所有小于deliveryTag的消息。</span><br><span class="line">                 */</span><br><span class="line">                channel.basicAck(envelope.getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        // 监听队列，第二个参数：是否自动进行消息确认。</span><br><span class="line">        //参数：String queue, boolean autoAck, Consumer callback</span><br><span class="line">        /**</span><br><span class="line">         * 参数明细：</span><br><span class="line">         * 1、queue 队列名称</span><br><span class="line">         * 2、autoAck 自动回复，当消费者接收到消息后要告诉mq消息已接收，如果将此参数设置为tru表示会自动回复mq，如果设置为<span class="literal">false</span>要通过编程实现回复</span><br><span class="line">         * 3、callback，消费方法，当消费者接收到消息要执行的方法</span><br><span class="line">         */</span><br><span class="line">        // channel.basicConsume(QUEUE_NAME, <span class="literal">true</span>, consumer);</span><br><span class="line"></span><br><span class="line">        // 监听队列，第二个参数<span class="literal">false</span>，手动进行ACK</span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="literal">false</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RabbitMQ的ACK机制的两种方式：<br>自动ACK：消息一旦被接收，消费者自动发送ACK<br>如果消息不太重要，丢失也没有影响，那么自动ACK会比较方便<br>手动ACK：消息接收后，不会发送ACK，需要手动调用<br>如果消息非常重要，不容丢失。那么最好在消费完成后手动ACK，否则接收消息后就自动ACK，RabbitMQ就会把消息从队列中删除。如果此时消费者宕机，那么消息就丢失了。</p><h3 id="竞争消费者模式"><a href="#竞争消费者模式" class="headerlink" title="竞争消费者模式"></a>竞争消费者模式</h3><p><img src="/post_imgs/rabbitmq_1-1-4.png" alt=""></p><p>也叫work queues模式，或者工作队列模式，与入门程序相比，多了一个消费端，两个消费端共同消费同一个队列中的消息，但是一个消息只能被一个消费者获取。<br>多个消费者可以订阅同一个Queue，这时Queue中的消息会被平均分摊给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理。通过 BasicQos 方法设置prefetchCount = 1, 实现能者多劳，避免一个消费者忙碌，另一个消费者空闲的情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">// 生产者 循环发送50条消息</span><br><span class="line">public class Send &#123;</span><br><span class="line">    private final static String QUEUE_NAME = <span class="string">"test_work_queue"</span>;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] argv) throws Exception &#123;</span><br><span class="line">        // 获取到连接</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        // 获取通道</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        // 声明队列</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, null);</span><br><span class="line">        // 循环发布任务</span><br><span class="line">        <span class="keyword">for</span> (int i = 0; i &lt; 50; i++) &#123;</span><br><span class="line">            // 消息内容</span><br><span class="line">            String message = <span class="string">"task .. "</span> + i;</span><br><span class="line">            channel.basicPublish(<span class="string">""</span>, QUEUE_NAME, null, message.getBytes());</span><br><span class="line">            System.out.println(<span class="string">" [x] Sent '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line"> </span><br><span class="line">            Thread.sleep(i * 2);</span><br><span class="line">        &#125;</span><br><span class="line">        // 关闭通道和连接</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 消费者1，消费者2</span><br><span class="line">public class Recv &#123;</span><br><span class="line">    private final static String QUEUE_NAME = <span class="string">"test_work_queue"</span>;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] argv) throws Exception &#123;</span><br><span class="line">        // 获取到连接</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        //创建会话通道,生产者和mq服务所有通信都在channel通道中完成</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        // 声明队列</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, null);</span><br><span class="line">        </span><br><span class="line">        // 设置每个消费者，同一时间点只能处理一条消息，此设置只在手动ack模式下有效</span><br><span class="line">        channel.basicQos(1);</span><br><span class="line">        //实现消费方法</span><br><span class="line">        DefaultConsumer consumer = new DefaultConsumer(channel)&#123;</span><br><span class="line">            // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span><br><span class="line">            @Override</span><br><span class="line">            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;</span><br><span class="line">                // body 即消息体</span><br><span class="line">                String msg = new String(body,<span class="string">"utf-8"</span>);</span><br><span class="line">                System.out.println(<span class="string">" [消费者1] received : "</span> + msg + <span class="string">"!"</span>);</span><br><span class="line">                //模拟任务耗时1s</span><br><span class="line">                try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">                channel.basicAck(envelope.getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        // 监听队列，第二个参数：是否自动进行消息确认。</span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="literal">false</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="订阅模型分类"><a href="#订阅模型分类" class="headerlink" title="订阅模型分类"></a>订阅模型分类</h2><p>说明下：<br>1、一个生产者多个消费者<br>2、每个消费者都有一个自己的队列<br>3、生产者没有将消息直接发送给队列，而是发送给exchange(交换机、转发器)<br>4、每个队列都需要绑定到交换机上<br>5、生产者发送的消息，经过交换机到达队列，实现一个消息被多个消费者消费<br>例子：注册-&gt;发邮件、发短信</p><p>X（Exchanges）：交换机一方面：接收生产者发送的消息。另一方面：知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。<br>Exchange（交换机）只负责转发消息，不具备存储消息的能力，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失。</p><p>Exchange类型有以下几种：<br>Fanout：广播，将消息交给所有绑定到交换机的队列<br>Direct：定向，把消息交给符合指定routing key 的队列<br>Topic：通配符，把消息交给符合routing pattern（路由模式） 的队列<br>Header：header模式与routing不同的地方在于，header模式取消routingkey，使用header中的 key/value（键值对）匹配队列。headers类型的Exchange不依赖于routing key与binding key的匹配规则来路由消息，而是根据发送的消息内容中的headers属性进行匹配。<br>在绑定Queue与Exchange时指定一组键值对；当消息发送到Exchange时，RabbitMQ会取到该消息的headers（也是一个键值对的形式），对比其中的键值对是否完全匹配Queue与Exchange绑定时指定的键值对；如果完全匹配则消息会路由到该Queue，否则不会路由到该Queue。</p><h3 id="Publish-subscribe（交换机类型：Fanout，也称为广播-）"><a href="#Publish-subscribe（交换机类型：Fanout，也称为广播-）" class="headerlink" title="Publish/subscribe（交换机类型：Fanout，也称为广播 ）"></a>Publish/subscribe（交换机类型：Fanout，也称为广播 ）</h3><p>将消息交给所有绑定到交换机的队列<br><img src="/post_imgs/rabbitmq_1-1-5.png" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">// 生产者</span><br><span class="line">public class Send &#123;</span><br><span class="line">    private final static String EXCHANGE_NAME = <span class="string">"test_fanout_exchange"</span>;</span><br><span class="line">    public static void main(String[] argv) throws Exception &#123;</span><br><span class="line">        // 获取到连接</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        // 获取通道</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        // 声明exchange，指定类型为fanout</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">"fanout"</span>);</span><br><span class="line">        </span><br><span class="line">        // 消息内容</span><br><span class="line">        String message = <span class="string">"注册成功！！"</span>;</span><br><span class="line">        // 发布消息到Exchange</span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME, <span class="string">""</span>, null, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">" [生产者] Sent '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line"> </span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 消费者1 （注册成功发给短信服务）</span><br><span class="line">public class Recv &#123;</span><br><span class="line">    private final static String QUEUE_NAME = <span class="string">"fanout_exchange_queue_sms"</span>;//短信队列</span><br><span class="line">    private final static String EXCHANGE_NAME = <span class="string">"test_fanout_exchange"</span>;</span><br><span class="line">    public static void main(String[] argv) throws Exception &#123;</span><br><span class="line">        // 获取到连接</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        // 获取通道</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        // 声明队列</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, null);</span><br><span class="line"> </span><br><span class="line">        // 绑定队列到交换机</span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">""</span>);</span><br><span class="line"> </span><br><span class="line">        // 定义队列的消费者</span><br><span class="line">        DefaultConsumer consumer = new DefaultConsumer(channel) &#123;</span><br><span class="line">            // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span><br><span class="line">            @Override</span><br><span class="line">            public void handleDelivery(String consumerTag,</span><br><span class="line">            Envelope envelope,</span><br><span class="line">            AMQP.BasicProperties properties,</span><br><span class="line">            byte[] body</span><br><span class="line">            ) throws IOException &#123;</span><br><span class="line">                // body 即消息体</span><br><span class="line">                String msg = new String(body);</span><br><span class="line">                System.out.println(<span class="string">" [短信服务] received : "</span> + msg + <span class="string">"!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        // 监听队列，自动返回完成</span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="literal">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 消费者2 （注册成功发给邮件服务）</span><br><span class="line">public class Recv2 &#123;</span><br><span class="line">    private final static String QUEUE_NAME = <span class="string">"fanout_exchange_queue_email"</span>;//邮件队列</span><br><span class="line">    private final static String EXCHANGE_NAME = <span class="string">"test_fanout_exchange"</span>;</span><br><span class="line">    public static void main(String[] argv) throws Exception &#123;</span><br><span class="line">        // 获取到连接</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        // 获取通道</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        // 声明队列</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, null);</span><br><span class="line"> </span><br><span class="line">        // 绑定队列到交换机</span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">""</span>);</span><br><span class="line">        </span><br><span class="line">        // 定义队列的消费者</span><br><span class="line">        DefaultConsumer consumer = new DefaultConsumer(channel) &#123;</span><br><span class="line">            // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span><br><span class="line">            @Override</span><br><span class="line">            public void handleDelivery(</span><br><span class="line">            String consumerTag,</span><br><span class="line">            Envelope envelope,</span><br><span class="line">            AMQP.BasicProperties properties,</span><br><span class="line">            byte[] body</span><br><span class="line">            ) throws IOException &#123;</span><br><span class="line">                // body 即消息体</span><br><span class="line">                String msg = new String(body);</span><br><span class="line">                System.out.println(<span class="string">" [邮件服务] received : "</span> + msg + <span class="string">"!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        // 监听队列，自动返回完成</span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="literal">true</span>, consumer);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="Routing-路由模型（交换机类型：direct）"><a href="#Routing-路由模型（交换机类型：direct）" class="headerlink" title="Routing 路由模型（交换机类型：direct）"></a>Routing 路由模型（交换机类型：direct）</h3><p>把消息交给符合指定routing key 的队列<br><img src="/post_imgs/rabbitmq_1-1-6.png" alt=""><br>P：生产者，向Exchange发送消息，发送消息时，会指定一个routing key。<br>X：Exchange（交换机），接收生产者的消息，然后把消息递交给 与routing key完全匹配的队列<br>C1：消费者，其所在队列指定了需要routing key 为 error 的消息<br>C2：消费者，其所在队列指定了需要routing key 为 info、error、warning 的消息<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">// 生产者</span><br><span class="line">public class Send &#123;</span><br><span class="line">    private final static String EXCHANGE_NAME = <span class="string">"test_direct_exchange"</span>;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] argv) throws Exception &#123;</span><br><span class="line">        // 获取到连接</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        // 获取通道</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        // 声明exchange，指定类型为direct</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class="line">        // 消息内容，</span><br><span class="line">        String message = <span class="string">"注册成功！请短信回复[T]退订"</span>;</span><br><span class="line">        // 发送消息，并且指定routing key 为：sms，只有短信服务能接收到消息</span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME, <span class="string">"sms"</span>, null, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">" [x] Sent '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line"> </span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 消费者1</span><br><span class="line">public class Recv &#123;</span><br><span class="line">    private final static String QUEUE_NAME = <span class="string">"direct_exchange_queue_sms"</span>;//短信队列</span><br><span class="line">    private final static String EXCHANGE_NAME = <span class="string">"test_direct_exchange"</span>;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] argv) throws Exception &#123;</span><br><span class="line">        // 获取到连接</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        // 获取通道</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        // 声明队列</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, null);</span><br><span class="line">        </span><br><span class="line">        // 绑定队列到交换机，同时指定需要订阅的routing key。可以指定多个</span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">"sms"</span>);//指定接收发送方指定routing key为sms的消息</span><br><span class="line">        //channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">"email"</span>);</span><br><span class="line"> </span><br><span class="line">        // 定义队列的消费者</span><br><span class="line">        DefaultConsumer consumer = new DefaultConsumer(channel) &#123;</span><br><span class="line">            // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span><br><span class="line">            @Override</span><br><span class="line">            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties,</span><br><span class="line">                                       byte[] body) throws IOException &#123;</span><br><span class="line">                // body 即消息体</span><br><span class="line">                String msg = new String(body);</span><br><span class="line">                System.out.println(<span class="string">" [短信服务] received : "</span> + msg + <span class="string">"!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        // 监听队列，自动ACK</span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="literal">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 消费者2</span><br><span class="line">public class Recv2 &#123;</span><br><span class="line">    private final static String QUEUE_NAME = <span class="string">"direct_exchange_queue_email"</span>;//邮件队列</span><br><span class="line">    private final static String EXCHANGE_NAME = <span class="string">"test_direct_exchange"</span>;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] argv) throws Exception &#123;</span><br><span class="line">        // 获取到连接</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        // 获取通道</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        // 声明队列</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, null);</span><br><span class="line">        </span><br><span class="line">        // 绑定队列到交换机，同时指定需要订阅的routing key。可以指定多个</span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">"email"</span>);//指定接收发送方指定routing key为email的消息</span><br><span class="line"> </span><br><span class="line">        // 定义队列的消费者</span><br><span class="line">        DefaultConsumer consumer = new DefaultConsumer(channel) &#123;</span><br><span class="line">            // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span><br><span class="line">            @Override</span><br><span class="line">            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties,</span><br><span class="line">                                       byte[] body) throws IOException &#123;</span><br><span class="line">                // body 即消息体</span><br><span class="line">                String msg = new String(body);</span><br><span class="line">                System.out.println(<span class="string">" [邮件服务] received : "</span> + msg + <span class="string">"!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        // 监听队列，自动ACK</span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="literal">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Topics-通配符模式（交换机类型：topics）"><a href="#Topics-通配符模式（交换机类型：topics）" class="headerlink" title="Topics 通配符模式（交换机类型：topics）"></a>Topics 通配符模式（交换机类型：topics）</h3><p>每个消费者监听自己的队列，并且设置带统配符的routingkey,生产者将消息发给broker，由交换机根据routingkey来转发消息到指定的队列。<br>Routingkey一般都是有一个或者多个单词组成，多个单词之间以“.”分割，例如：inform.sms<br>通配符规则：<br>#：匹配一个或多个词<br>*：匹配不多不少恰好1个词</p><p><img src="/post_imgs/rabbitmq_1-1-7.png" alt=""></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">// 生产者</span><br><span class="line">public class Send &#123;</span><br><span class="line">    private final static String EXCHANGE_NAME = <span class="string">"test_topic_exchange"</span>;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] argv) throws Exception &#123;</span><br><span class="line">        // 获取到连接</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        // 获取通道</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        // 声明exchange，指定类型为topic</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);</span><br><span class="line">        // 消息内容</span><br><span class="line">        String message = <span class="string">"这是一只行动迅速的橙色的兔子"</span>;</span><br><span class="line">        // 发送消息，并且指定routing key为：quick.orange.rabbit</span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME, <span class="string">"quick.orange.rabbit"</span>, null, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">" [动物描述：] Sent '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line"> </span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 消费者1</span><br><span class="line">public class Recv &#123;</span><br><span class="line">    private final static String QUEUE_NAME = <span class="string">"topic_exchange_queue_Q1"</span>;</span><br><span class="line">    private final static String EXCHANGE_NAME = <span class="string">"test_topic_exchange"</span>;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] argv) throws Exception &#123;</span><br><span class="line">        // 获取到连接</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        // 获取通道</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        // 声明队列</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, null);</span><br><span class="line">        </span><br><span class="line">        // 绑定队列到交换机，同时指定需要订阅的routing key。订阅所有的橙色动物</span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">"*.orange.*"</span>);</span><br><span class="line"> </span><br><span class="line">        // 定义队列的消费者</span><br><span class="line">        DefaultConsumer consumer = new DefaultConsumer(channel) &#123;</span><br><span class="line">            // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span><br><span class="line">            @Override</span><br><span class="line">            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties,</span><br><span class="line">                                       byte[] body) throws IOException &#123;</span><br><span class="line">                // body 即消息体</span><br><span class="line">                String msg = new String(body);</span><br><span class="line">                System.out.println(<span class="string">" [消费者1] received : "</span> + msg + <span class="string">"!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        // 监听队列，自动ACK</span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="literal">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 消费者2</span><br><span class="line">public class Recv2 &#123;</span><br><span class="line">    private final static String QUEUE_NAME = <span class="string">"topic_exchange_queue_Q2"</span>;</span><br><span class="line">    private final static String EXCHANGE_NAME = <span class="string">"test_topic_exchange"</span>;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] argv) throws Exception &#123;</span><br><span class="line">        // 获取到连接</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        // 获取通道</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        // 声明队列</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, null);</span><br><span class="line">        </span><br><span class="line">        // 绑定队列到交换机，同时指定需要订阅的routing key。订阅关于兔子以及懒惰动物的消息</span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">"*.*.rabbit"</span>);</span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">"lazy.＃"</span>);</span><br><span class="line"> </span><br><span class="line">        // 定义队列的消费者</span><br><span class="line">        DefaultConsumer consumer = new DefaultConsumer(channel) &#123;</span><br><span class="line">            // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span><br><span class="line">            @Override</span><br><span class="line">            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties,</span><br><span class="line">                                       byte[] body) throws IOException &#123;</span><br><span class="line">                // body 即消息体</span><br><span class="line">                String msg = new String(body);</span><br><span class="line">                System.out.println(<span class="string">" [消费者2] received : "</span> + msg + <span class="string">"!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        // 监听队列，自动ACK</span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="literal">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RPC-模式"><a href="#RPC-模式" class="headerlink" title="RPC 模式"></a>RPC 模式</h3><p><img src="/post_imgs/rabbitmq_1-1-8.png" alt=""><br>流程说明：<br>1、 当客户端启动的时候，它创建一个匿名独享的回调队列。<br>2、 在 RPC 请求中，客户端发送带有两个属性的消息：一个是设置回调队列的 reply_to 属性，另一个是设置唯一值的 correlation_id 属性。<br>3、 将请求发送到一个 rpc_queue 队列中。<br>4、 服务器等待请求发送到这个队列中来。当请求出现的时候，它执行他的工作并且将带有执行结果的消息发送给 reply_to 字段指定的队列。<br>5、 客户端等待回调队列里的数据。当有消息出现的时候，它会检查 correlation_id 属性。如果此属性的值与请求匹配，将它返回给应用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;RabbitMQ 是一个开源的消息代理和队列服务器，用来通过普通协议在完全不同的应用之间共享数据，RabbitMQ是使用 Erlang语言来
      
    
    </summary>
    
    
      <category term="RabbitMQ" scheme="http://luckymartinlee.github.io/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch从入门到放弃(三) -- 查询一</title>
    <link href="http://luckymartinlee.github.io/2018/07/11/elasticsearch_1-4/"/>
    <id>http://luckymartinlee.github.io/2018/07/11/elasticsearch_1-4/</id>
    <published>2018-07-11T07:11:21.000Z</published>
    <updated>2020-12-17T09:58:43.105Z</updated>
    
    <content type="html"><![CDATA[<h2 id="查询方式"><a href="#查询方式" class="headerlink" title="查询方式"></a>查询方式</h2><p>1 使用Search Lite API，并将所有的搜索参数都通过URL传递<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 下面是在所有的字段中搜索带有<span class="string">"John"</span>的结果，相当于指定 _all 字段</span><br><span class="line">curl -XGET <span class="string">'localhost:9200/megacorp/employee/_search?q=John'</span></span><br><span class="line"></span><br><span class="line">// 指定地段查询， 如指定 interests 字段</span><br><span class="line">curl -XGET <span class="string">'localhost:9200/megacorp/employee/_search?q=interests:music'</span></span><br></pre></td></tr></table></figure></p><p>2 使用Elasticsearch DSL，其可以通过传递一个JSON请求来获取结果。<br>DSL方式提供了更加灵活的方式来构建更加复杂的查询（我们将在后面看到），甚至指定你想要的返回结果<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 等价于上面的 在所有的字段中搜索带有<span class="string">"John"</span>的结果</span><br><span class="line">curl -XGET <span class="string">'localhost:9200/megacorp/_search'</span> -d <span class="string">'</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    "query": &#123;</span></span><br><span class="line"><span class="string">        "multi_match" : &#123;</span></span><br><span class="line"><span class="string">            "query" : "John",</span></span><br><span class="line"><span class="string">            "fields" : ["_all"]</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;'</span></span><br></pre></td></tr></table></figure></p><h2 id="基本查询"><a href="#基本查询" class="headerlink" title="基本查询"></a>基本查询</h2><p>term查询和terms查询<br>不进行分词查询，直接去倒排索引中匹配确切的term。<br>term:查询某个字段里含有某个关键词的文档<br>terms:查询某个字段里含有多个关键词的文档，关键词之间是或关系<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">get /lib3/user/_search/</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"query"</span>:&#123;<span class="string">"term"</span>:&#123; <span class="string">"interests"</span>:<span class="string">"youyong"</span>&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">get lib3/user/_search/</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"query"</span>:&#123;<span class="string">"terms"</span>:&#123;<span class="string">"interests"</span>:[<span class="string">"shufa"</span>,<span class="string">"youyong"</span>]&#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>match查询<br>对查询关键字进行查询分词<br>match:先进行分词操作，然后再查询</p><p>match_all:查询所有文档</p><p>match_phrase:短语匹配查询，可以指定slop分词间隔多远。相隔多远的意思是，你需要移动一个词条多少次来让查询和文档匹配。</p><p>match_phrase_prefix: 前缀查询，根据短语中最后一个分词来做前缀匹配，注意和max_expanions搭配。其实默认是50</p><p>multi_match：多字段查询，使用相当的灵活，可以完成match_phrase和match_phrase_prefix的工作。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">GET lib3/user/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"query"</span>:&#123;<span class="string">"match"</span>:&#123;<span class="string">"age"</span>: 20&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// match_all的值为空，表示没有查询条件，那就是查询全部。就像select * from table_name一样</span><br><span class="line">GET lib3/user/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"query"</span>:&#123;</span><br><span class="line">    <span class="string">"match_all"</span>: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">get lib3/user/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"query"</span>:&#123;</span><br><span class="line">    <span class="string">"match_phrase"</span>:&#123;<span class="string">"interests"</span>: <span class="string">"youyong shufa"</span>,<span class="string">"slop"</span>: 2&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">get lib3/user/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"query"</span>:&#123;</span><br><span class="line">    <span class="string">"match_phrase_prefix"</span>:&#123;<span class="string">"interests"</span>: <span class="string">"you"</span>,<span class="string">"max_expansions"</span>: 1&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET lib3/user/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"query"</span>:&#123;</span><br><span class="line">    <span class="string">"multi_match"</span>: &#123;</span><br><span class="line">      <span class="string">"query"</span>: <span class="string">"youyong"</span>,</span><br><span class="line">      <span class="string">"fields"</span>:[<span class="string">"interests"</span>,<span class="string">"name"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// multi_match 实现 match_phrase_prefix 功能</span><br><span class="line">GET lib3/user/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"query"</span>: &#123;</span><br><span class="line">    <span class="string">"multi_match"</span>: &#123;</span><br><span class="line">      <span class="string">"query"</span>: <span class="string">"gi"</span>,</span><br><span class="line">      <span class="string">"fields"</span>: [<span class="string">"title"</span>],</span><br><span class="line">      <span class="string">"type"</span>: <span class="string">"phrase_prefix"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// multi_match 实现 match_phrase功能</span><br><span class="line">GET lib3/user/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"query"</span>: &#123;</span><br><span class="line">    <span class="string">"multi_match"</span>: &#123;</span><br><span class="line">      <span class="string">"query"</span>: <span class="string">"girl"</span>,</span><br><span class="line">      <span class="string">"fields"</span>: [<span class="string">"title"</span>],</span><br><span class="line">      <span class="string">"type"</span>: <span class="string">"phrase"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET lib3/user/_search</span><br><span class="line">&#123;</span><br><span class="line">   <span class="string">"multi_match"</span> : &#123;</span><br><span class="line">      <span class="string">"query"</span> : <span class="string">"北京天安门"</span>,</span><br><span class="line">      // <span class="built_in">type</span> 默认是best_field，词条匹配度越高，得分越高，此外还有</span><br><span class="line">      // most_fields, 词条命中数量越多，得分越高</span><br><span class="line">      // cross_fields, 字段命中的越多，得分越高</span><br><span class="line">      <span class="string">"type"</span> : <span class="string">"best_fields"</span>, </span><br><span class="line">      // 词条之间 逻辑关系，默认是 or</span><br><span class="line">      <span class="string">"operator"</span>: <span class="string">"and"</span>,</span><br><span class="line">      //</span><br><span class="line">      <span class="string">"tie_breaker"</span> : 0.3,</span><br><span class="line">      <span class="string">"fields"</span> : [ <span class="string">"title"</span>, <span class="string">"body"</span> ],</span><br><span class="line">      <span class="string">"minimun_should_match"</span> : <span class="string">"30%"</span> // 至少要有30%的词条被搜索到，才命中,对most_fields 无效</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Boosting 字段权重调整<br>如搜索请求在多个field中查询，想提高某个field的查询权重,下面的例子中，我们把interests的权重调成3，这样就提高了其在结果中的权重。<br>Boosting不仅仅意味着计算出来的分数(calculated score)直接乘以boost factor，最终的boost value会经过归一化以及其他一些内部的优化。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET <span class="string">'localhost:9200/megacorp/employee/_search'</span> -d <span class="string">'</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    "query": &#123;</span></span><br><span class="line"><span class="string">        "multi_match" : &#123;</span></span><br><span class="line"><span class="string">            "query" : "rock",</span></span><br><span class="line"><span class="string">            "fields": ["about", "interests^3"]</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;'</span></span><br></pre></td></tr></table></figure></p><p>Bool Query  布尔查询<br>布尔查询可以接受一个must参数(等价于AND)，一个must_not参数(等价于NOT)，以及一个should参数(等价于OR)。比如，我想查询about中出现music或者climb关键字的员工，员工的名字是John，但姓氏不是smith，我们可以这么来查询：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET <span class="string">'localhost:9200/megacorp/employee/_search'</span> -d <span class="string">'</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    "query": &#123;</span></span><br><span class="line"><span class="string">        "bool": &#123;</span></span><br><span class="line"><span class="string">                "must": &#123;</span></span><br><span class="line"><span class="string">                    "bool" : &#123; </span></span><br><span class="line"><span class="string">                        "should": [</span></span><br><span class="line"><span class="string">                            &#123; "match": &#123; "about": "music" &#125;&#125;,</span></span><br><span class="line"><span class="string">                            &#123; "match": &#123; "about": "climb" &#125;&#125; ] </span></span><br><span class="line"><span class="string">                    &#125;</span></span><br><span class="line"><span class="string">                &#125;,</span></span><br><span class="line"><span class="string">                "must": &#123;</span></span><br><span class="line"><span class="string">                    "match": &#123; "first_nale": "John" &#125;</span></span><br><span class="line"><span class="string">                &#125;,</span></span><br><span class="line"><span class="string">                "must_not": &#123;</span></span><br><span class="line"><span class="string">                    "match": &#123;"last_name": "Smith" &#125;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;'</span></span><br></pre></td></tr></table></figure></p><p>Fuzzy Queries 模糊查询<br>模糊查询可以在Match和 Multi-Match查询中使用以便解决拼写的错误，模糊度是基于 Levenshtein Edit Distance 计算与原单词的距离。使用如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET <span class="string">'localhost:9200/megacorp/employee/_search'</span> -d <span class="string">'</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    "query": &#123;</span></span><br><span class="line"><span class="string">        "multi_match" : &#123;</span></span><br><span class="line"><span class="string">            "query" : "rock climb",</span></span><br><span class="line"><span class="string">            "fields": ["about", "interests"],</span></span><br><span class="line"><span class="string">            "fuzziness": "AUTO"</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    "_source": ["about", "interests", "first_name"],</span></span><br><span class="line"><span class="string">    "size": 1</span></span><br><span class="line"><span class="string">&#125;'</span></span><br></pre></td></tr></table></figure></p><p>fuzziness 参数的取值如下:<br>1) 0,1,2<br>表示最大可允许的莱文斯坦距离</p><p>2) AUTO<br>会根据词项的长度来产生可编辑距离，它还有两个可选参数，形式为AUTO:[low],[high]， 分别表示短距离参数和长距离参数；如果没有指定，默认值是 AUTO:3,6 表示的意义如下</p><pre><code>2.1) 0..2单词长度为 0 到 2 之间时必须要精确匹配，这其实很好理解，单词长度太短是没有相似度可言的，例如 &apos;a&apos; 和 &apos;b&apos;。2.2) 3..5单词长度 3 到 5 个字母时，最大编辑距离为 12.3) &gt;5单词长度大于 5 个字母时，最大编辑距离为 2</code></pre><p>如果不设置 fuziness 参数，查询是精确匹配的。<br>fuzziness 在绝大多数场合都应该设置成 AUTO</p><p>Wildcard Query 通配符查询<br>通配符查询允许我们指定一个模式来匹配，而不需要指定完整的trem。<br>? 将会匹配如何字符；</p><ul><li>将会匹配零个或者多个字符。<br>如想查找所有名字中以J字符开始的记录，我们可以如下使用：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET <span class="string">'localhost:9200/megacorp/employee/_search'</span> -d <span class="string">'</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    "query": &#123;</span></span><br><span class="line"><span class="string">            "wildcard" : &#123;</span></span><br><span class="line"><span class="string">                "first_name" : "s*"</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        "_source": ["first_name", "last_name"],</span></span><br><span class="line"><span class="string">    "highlight": &#123;</span></span><br><span class="line"><span class="string">            "fields" : &#123;</span></span><br><span class="line"><span class="string">                "first_name" : &#123;&#125;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">&#125;'</span></span><br></pre></td></tr></table></figure></li></ul><p>Regexp Query 正则表达式查询<br>如查找作者名字以J字符开头，中间是若干个a-z之间的字符，并且以字符n结束的记录，可以如下查询：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET <span class="string">'localhost:9200/megacorp/employee/_search'</span> -d <span class="string">'</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    "query": &#123;</span></span><br><span class="line"><span class="string">        "regexp" : &#123;</span></span><br><span class="line"><span class="string">            "first_name" : "J[a-z]*n"</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    "_source": ["first_name", "age"],</span></span><br><span class="line"><span class="string">    "highlight": &#123;</span></span><br><span class="line"><span class="string">        "fields" : &#123;</span></span><br><span class="line"><span class="string">            "first_name" : &#123;&#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;'</span></span><br></pre></td></tr></table></figure></p><p>Match Phrase Query 匹配短语查询<br>匹配短语查询要求查询字符串中的trems要么都出现Document中、要么trems按照输入顺序依次出现在结果中。在默认情况下，查询输入的trems必须在搜索字符串紧挨着出现，否则将查询不到。不过我们可以指定slop参数，来控制输入的trems之间，通过最多几次转换能够搜索到<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET <span class="string">'localhost:9200/megacorp/employee/_search'</span> -d <span class="string">'</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    "query": &#123;</span></span><br><span class="line"><span class="string">        "multi_match": &#123;</span></span><br><span class="line"><span class="string">            "query": "climb rock",</span></span><br><span class="line"><span class="string">            "fields": [</span></span><br><span class="line"><span class="string">                "about",</span></span><br><span class="line"><span class="string">                "interests"</span></span><br><span class="line"><span class="string">            ],</span></span><br><span class="line"><span class="string">            "type": "phrase",</span></span><br><span class="line"><span class="string">            "slop": 3</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    "_source": [</span></span><br><span class="line"><span class="string">        "title",</span></span><br><span class="line"><span class="string">        "about",</span></span><br><span class="line"><span class="string">        "interests"</span></span><br><span class="line"><span class="string">    ]</span></span><br><span class="line"><span class="string">&#125;'</span></span><br></pre></td></tr></table></figure></p><p>Match Phrase Prefix Query 匹配短语前缀查询<br>匹配短语前缀查询可以指定单词的一部分字符前缀即可查询到该单词，和match phrase query一样我们也可以指定slop参数；同时其还支持max_expansions参数限制被匹配到的terms数量来减少资源的使用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET <span class="string">'localhost:9200/megacorp/employee/_search'</span> -d <span class="string">'</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    "query": &#123;</span></span><br><span class="line"><span class="string">        "match_phrase_prefix": &#123;</span></span><br><span class="line"><span class="string">            "summary": &#123;</span></span><br><span class="line"><span class="string">                "query": "cli ro",</span></span><br><span class="line"><span class="string">                "slop": 3,</span></span><br><span class="line"><span class="string">                "max_expansions": 10</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    "_source": [</span></span><br><span class="line"><span class="string">        "about",</span></span><br><span class="line"><span class="string">        "interests",</span></span><br><span class="line"><span class="string">        "first_name"</span></span><br><span class="line"><span class="string">    ]</span></span><br><span class="line"><span class="string">&#125;'</span></span><br></pre></td></tr></table></figure></p><p>Query String<br>query_string查询提供了一种手段可以使用一种简洁的方式运行multi_match queries, bool queries, boosting, fuzzy matching, wildcards, regexp以及range queries的组合查询。在下面的例子中，我们运行了一个模糊搜索(fuzzy search)，搜索关键字是search algorithm，并且作者包含grant ingersoll或者tom morton。并且搜索了所有的字段，其中summary字段的权重为2<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET <span class="string">'localhost:9200/megacorp/employee/_search'</span> -d <span class="string">'</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    "query": &#123;</span></span><br><span class="line"><span class="string">        "query_string" : &#123;</span></span><br><span class="line"><span class="string">            "query": "(saerch~1 algorithm~1) AND (grant ingersoll) OR (tom morton)",</span></span><br><span class="line"><span class="string">            "fields": ["_all", "summary^2"]</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    "_source": [ "title", "summary", "authors" ],</span></span><br><span class="line"><span class="string">    "highlight": &#123;</span></span><br><span class="line"><span class="string">        "fields" : &#123;</span></span><br><span class="line"><span class="string">            "summary" : &#123;&#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;'</span></span><br></pre></td></tr></table></figure></p><p>Simple Query String 简单查询字符串<br>simple_query_string是query_string的另一种版本，其更适合为用户提供一个搜索框中，因为其使用+/|/- 分别替换AND/OR/NOT，如果用输入了错误的查询，其直接忽略这种情况而不是抛出异常。使用如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">curl -POST <span class="string">'localhost:9200/megacorp/employee/_search'</span> -d <span class="string">'</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    "query": &#123;</span></span><br><span class="line"><span class="string">        "simple_query_string" : &#123;</span></span><br><span class="line"><span class="string">        "query": "(saerch~1 algorithm~1) + (grant ingersoll) | (tom morton)",</span></span><br><span class="line"><span class="string">        "fields": ["_all", "summary^2"]</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    "_source": [ "title", "summary", "authors" ],</span></span><br><span class="line"><span class="string">    "highlight": &#123;</span></span><br><span class="line"><span class="string">        "fields" : &#123;</span></span><br><span class="line"><span class="string">            "summary" : &#123;&#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;'</span></span><br></pre></td></tr></table></figure></p><p>Sorted 结果排序<br>对输出结果按照多层进行排序<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST <span class="string">'localhost:9200/megacorp/employee/_search'</span> -d <span class="string">'</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    "query": &#123;</span></span><br><span class="line"><span class="string">        "term" : &#123;</span></span><br><span class="line"><span class="string">            "interests": "music"</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    "_source" : ["interests","first_name","about"],</span></span><br><span class="line"><span class="string">    "sort": [</span></span><br><span class="line"><span class="string">        &#123; "publish_date": &#123;"order":"desc"&#125;&#125;,</span></span><br><span class="line"><span class="string">        &#123; "id": &#123; "order": "desc" &#125;&#125;</span></span><br><span class="line"><span class="string">    ]</span></span><br><span class="line"><span class="string">&#125;'</span></span><br></pre></td></tr></table></figure></p><p>Range Query 范围查询<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST <span class="string">'localhost:9200/person/worker/_search?pretty'</span> -d <span class="string">'</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    "query": &#123;</span></span><br><span class="line"><span class="string">        "range" : &#123;</span></span><br><span class="line"><span class="string">            "birthday": &#123;</span></span><br><span class="line"><span class="string">                "gte": "2017-02-01",</span></span><br><span class="line"><span class="string">                "lte": "2017-05-01"</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    "_source" : ["first_name","last_name","birthday"]</span></span><br><span class="line"><span class="string">&#125;'</span></span><br></pre></td></tr></table></figure></p><p>Filtered Query 过滤查询<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST :9200/megacorp/employee/_search?pretty<span class="string">' -d '</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"query"</span>: &#123;</span><br><span class="line">        <span class="string">"filtered"</span>: &#123;</span><br><span class="line">            <span class="string">"query"</span> : &#123;</span><br><span class="line">                <span class="string">"multi_match"</span>: &#123;</span><br><span class="line">                    <span class="string">"query"</span>: <span class="string">"music"</span>,</span><br><span class="line">                    <span class="string">"fields"</span>: [<span class="string">"about"</span>,<span class="string">"interests"</span>]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"filter"</span>: &#123;</span><br><span class="line">                <span class="string">"range"</span> : &#123;</span><br><span class="line">                    <span class="string">"birthday"</span>: &#123;</span><br><span class="line">                        <span class="string">"gte"</span>: 2017-02-01</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"_source"</span> : [<span class="string">"first_name"</span>,<span class="string">"last_name"</span>,<span class="string">"about"</span>, <span class="string">"interests"</span>]</span><br><span class="line">&#125;<span class="string">'</span></span><br></pre></td></tr></table></figure></p><p>过滤查询(Filtered queries)并不强制过滤条件中指定查询,如果没有指定查询条件，则会运行match_all查询，其将会返回index中所有文档，然后对其进行过滤，在实际运用中，过滤器应该先被执行，这样可以减少需要查询的范围，而且，第一次使用fliter之后其将会被缓存，这样会对性能代理提升。Filtered queries在Elasticsearch 5.0中移除了，我们可以使用bool查询来替换他，下面是使用bool查询来实现上面一样的查询效果，返回结果一样：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST <span class="string">'localhost:9200/megacorp/employee/_search?pretty'</span> -d <span class="string">'</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    "query": &#123;</span></span><br><span class="line"><span class="string">        "bool": &#123;</span></span><br><span class="line"><span class="string">            "must" : &#123;</span></span><br><span class="line"><span class="string">                "multi_match": &#123;</span></span><br><span class="line"><span class="string">                    "query": "music",</span></span><br><span class="line"><span class="string">                    "fields": ["about","interests"]</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">            "filter": &#123;</span></span><br><span class="line"><span class="string">                "range" : &#123;</span></span><br><span class="line"><span class="string">                    "birthday": &#123;</span></span><br><span class="line"><span class="string">                        "gte": 2017-02-01</span></span><br><span class="line"><span class="string">                    &#125;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    "_source" : ["first_name","last_name","about", "interests"]</span></span><br><span class="line"><span class="string">&#125;'</span></span><br></pre></td></tr></table></figure></p><p>Multiple Filters 多过滤器查询<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST <span class="string">'localhost:9200/iteblog_book_index/book/_search?pretty'</span> -d <span class="string">'</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    "query": &#123;</span></span><br><span class="line"><span class="string">        "filtered": &#123;</span></span><br><span class="line"><span class="string">            "query" : &#123;</span></span><br><span class="line"><span class="string">                "multi_match": &#123;</span></span><br><span class="line"><span class="string">                "query": "elasticsearch",</span></span><br><span class="line"><span class="string">                "fields": ["title","summary"]</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">            "filter": &#123;</span></span><br><span class="line"><span class="string">                "bool": &#123;</span></span><br><span class="line"><span class="string">                    "must": &#123;</span></span><br><span class="line"><span class="string">                        "range" : &#123; "num_reviews": &#123; "gte": 20 &#125; &#125;</span></span><br><span class="line"><span class="string">                    &#125;,</span></span><br><span class="line"><span class="string">                    "must_not": &#123;</span></span><br><span class="line"><span class="string">                        "range" : &#123; "publish_date": &#123; "lte": "2014-12-31" &#125; &#125;</span></span><br><span class="line"><span class="string">                    &#125;,</span></span><br><span class="line"><span class="string">                    "should": &#123;</span></span><br><span class="line"><span class="string">                        "term": &#123; "publisher": "oreilly" &#125;</span></span><br><span class="line"><span class="string">                    &#125;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    "_source" : ["title","summary","publisher", "num_reviews", "publish_date"]</span></span><br><span class="line"><span class="string">&#125;'</span></span><br></pre></td></tr></table></figure></p><p>Function Score: Field Value Factor 自定义得分计算<br>在某些场景下，你可能想对某个特定字段设置一个因子(factor)，并通过这个因子计算某个文档的相关度(relevance score)。这是典型地基于文档(document)的重要性来抬高其相关性的方式。在下面例子中，我们想找到更受欢迎的图书(是通过图书的评论实现的)，并将其权重抬高，这里可以通过使用field_value_factor来实现<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST <span class="string">'localhost:9200/iteblog_book_index/book/_search?pretty'</span> -d <span class="string">'</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    "query": &#123;</span></span><br><span class="line"><span class="string">        "function_score": &#123;</span></span><br><span class="line"><span class="string">            "query": &#123;</span></span><br><span class="line"><span class="string">                "multi_match" : &#123;</span></span><br><span class="line"><span class="string">                    "query" : "search engine",</span></span><br><span class="line"><span class="string">                    "fields": ["title", "summary"]</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">            "field_value_factor": &#123;</span></span><br><span class="line"><span class="string">                "field" : "num_reviews",</span></span><br><span class="line"><span class="string">                "modifier": "log1p",</span></span><br><span class="line"><span class="string">                "factor" : 2</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    "_source": ["title", "summary", "publish_date", "num_reviews"]</span></span><br><span class="line"><span class="string">&#125;'</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;查询方式&quot;&gt;&lt;a href=&quot;#查询方式&quot; class=&quot;headerlink&quot; title=&quot;查询方式&quot;&gt;&lt;/a&gt;查询方式&lt;/h2&gt;&lt;p&gt;1 使用Search Lite API，并将所有的搜索参数都通过URL传递&lt;br&gt;&lt;figure class=&quot;highli
      
    
    </summary>
    
    
      <category term="Elasticsearch" scheme="http://luckymartinlee.github.io/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>Hadoop从入门到放弃(四) -- YARN</title>
    <link href="http://luckymartinlee.github.io/2018/06/22/hadoop-1-4/"/>
    <id>http://luckymartinlee.github.io/2018/06/22/hadoop-1-4/</id>
    <published>2018-06-22T07:15:21.000Z</published>
    <updated>2020-12-07T12:52:05.467Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是-YARN"><a href="#什么是-YARN" class="headerlink" title="什么是 YARN"></a>什么是 YARN</h2><p>YARN 是 Hadoop2.0 以后的资源管理器，负责整个集群资源的管理和调度</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="ResourceManager"><a href="#ResourceManager" class="headerlink" title="ResourceManager"></a>ResourceManager</h3><p>负责:</p><ol><li>分配和调度资源</li><li>启动并监控 ApplicationMaster</li><li>监控 NodeManager</li></ol><h3 id="ApplicationMaster"><a href="#ApplicationMaster" class="headerlink" title="ApplicationMaster"></a>ApplicationMaster</h3><p>负责:</p><ol><li>为 MapReduce 类型程序申请资源，并分配给内部任务</li><li>负责数据的切分</li><li>监控任务的执行以及容错</li></ol><h3 id="NodeManager"><a href="#NodeManager" class="headerlink" title="NodeManager"></a>NodeManager</h3><p>负责:</p><ol><li>管理单个节点</li><li>处理来自 ResouceManager 的命令</li><li>处理来自 ApplicationMaster 的命令</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是-YARN&quot;&gt;&lt;a href=&quot;#什么是-YARN&quot; class=&quot;headerlink&quot; title=&quot;什么是 YARN&quot;&gt;&lt;/a&gt;什么是 YARN&lt;/h2&gt;&lt;p&gt;YARN 是 Hadoop2.0 以后的资源管理器，负责整个集群资源的管理和调度&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="Hadoop" scheme="http://luckymartinlee.github.io/tags/Hadoop/"/>
    
      <category term="大数据" scheme="http://luckymartinlee.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="YARN" scheme="http://luckymartinlee.github.io/tags/YARN/"/>
    
  </entry>
  
  <entry>
    <title>Hadoop从入门到放弃(三) -- MapReduce</title>
    <link href="http://luckymartinlee.github.io/2018/06/12/hadoop-1-3/"/>
    <id>http://luckymartinlee.github.io/2018/06/12/hadoop-1-3/</id>
    <published>2018-06-12T07:15:40.000Z</published>
    <updated>2020-12-07T12:51:53.831Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MapReduce-编程模型"><a href="#MapReduce-编程模型" class="headerlink" title="MapReduce 编程模型"></a>MapReduce 编程模型</h2><p>举个栗子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入一个大文件，通过Split切分后，将其分成多个分片，</span><br><span class="line">每个文件分片，由单独的机器去处理，这就是 Map 方法，</span><br><span class="line">然后，将各个机器的计算结果进行汇总并得到最终的结果，这就是 Reduce 方法。</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;MapReduce-编程模型&quot;&gt;&lt;a href=&quot;#MapReduce-编程模型&quot; class=&quot;headerlink&quot; title=&quot;MapReduce 编程模型&quot;&gt;&lt;/a&gt;MapReduce 编程模型&lt;/h2&gt;&lt;p&gt;举个栗子：&lt;br&gt;&lt;figure class
      
    
    </summary>
    
    
      <category term="Hadoop" scheme="http://luckymartinlee.github.io/tags/Hadoop/"/>
    
      <category term="大数据" scheme="http://luckymartinlee.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="MapReduce" scheme="http://luckymartinlee.github.io/tags/MapReduce/"/>
    
  </entry>
  
  <entry>
    <title>MySQL -- 查询优化 一</title>
    <link href="http://luckymartinlee.github.io/2018/05/22/mysql-2-1/"/>
    <id>http://luckymartinlee.github.io/2018/05/22/mysql-2-1/</id>
    <published>2018-05-22T10:45:50.000Z</published>
    <updated>2021-01-03T07:11:18.575Z</updated>
    
    <content type="html"><![CDATA[<h2 id="索引建立技巧"><a href="#索引建立技巧" class="headerlink" title="索引建立技巧"></a>索引建立技巧</h2><h3 id="单个字段-“等于”-查询"><a href="#单个字段-“等于”-查询" class="headerlink" title="单个字段 “等于” 查询"></a>单个字段 “等于” 查询</h3><p>形如:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM `tabel1` WHERE `f1` = 15</span><br></pre></td></tr></table></figure></p><p>这种情况下，毫无疑问，需要给字段 (f1) 加上索引。</p><p>形如:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT `f2`,`f3` FROM `tabel1` WHERE `f1` = 15</span><br></pre></td></tr></table></figure></p><p>此时应该创建 (f1,f2,f3) 索引，此索引起到覆盖索引的作用，效率比 (f1) 索引高。切记，不应该创建 (f2,f3,f1) 索引，因为根据索引 “最左原则”，它对 f1 字段起不到查询过滤作用。</p><h3 id="多个字段-“等于”-查询"><a href="#多个字段-“等于”-查询" class="headerlink" title="多个字段 “等于” 查询"></a>多个字段 “等于” 查询</h3><p>形如:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM `tabel1` WHERE `f1` = 15 AND `f2` = <span class="string">"abc"</span></span><br></pre></td></tr></table></figure></p><p>这种情况下，应该创建 (f1,f2)索引 或者 (f2,f1)索引 都是可以的。<br>有人会问，如果创建两个单独是索引，分别是 (f1)索引 和 (f2)索引 可以吗？这里不建议这么做，虽然MySQL根据index_merge算法能同时使用这两个索引，但这样效率依旧不如上面联合索引。</p><h3 id="字段-“等于”-和-“不等于”-混合查询"><a href="#字段-“等于”-和-“不等于”-混合查询" class="headerlink" title="字段 “等于” 和 “不等于” 混合查询"></a>字段 “等于” 和 “不等于” 混合查询</h3><p>形如:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM `tabel1` WHERE `f1` &gt; 15 AND `f2` = <span class="string">"abc"</span></span><br></pre></td></tr></table></figure></p><p>对于这种情况，我们要小心处理，因为只要有一列使用了不等于计算，那么它将阻止其他列使用索引。<br>此时我们应该创建 (f2,f1) 索引，这时候f1和f2两个条件都会走索引，这才是我们想要的。而不是 (f1,f2) 索引，这种情况下，只有 f1 会使用索引，相对来说效率较低。</p><p>形如:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM `tabel1` WHERE `f1` &gt; 15 AND `f3` &lt; 100 AND `f2` = <span class="string">"abc"</span></span><br></pre></td></tr></table></figure></p><p>这是有两个 “不等于” 查询，因此我们不可能做到 f1,f2,f3都做到被索引覆盖，<br>此时需要依据实际数据情况，建立 (f2,f1)索引 或 (f2,f3)索引，其中关键是，一定要把 “等于” 字段，放在索引的最左侧。</p><h3 id="多个字段-“等于”-和-“排序”-查询"><a href="#多个字段-“等于”-和-“排序”-查询" class="headerlink" title="多个字段 “等于” 和 “排序” 查询"></a>多个字段 “等于” 和 “排序” 查询</h3><p>形如:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM `tabel1` WHERE `f1` = 15 AND `f2` = <span class="string">"abc"</span> ORDER BY `f3`</span><br></pre></td></tr></table></figure></p><p>此时我们建立索引的字段顺序，应该是: “先是过滤字段，后是排序字段”，所以此处应该建立 (f1,f2,f3)索引 或者 (f2,f1,f3)索引。而不应该 建立 (f3,f1,f2)索引 或者 (f3,f2,f1)索引，因为这些只使用了索引排序，没有使用索引过滤。</p><p>形如:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT `f4`,`f5` FROM `tabel1` WHERE `f1` = 15 AND `f2` = <span class="string">"abc"</span> ORDER BY `f3`</span><br></pre></td></tr></table></figure></p><p>此时我们可以创建 (f1,f2,f3,f4,f5)索引 或 (f2,f1,f3,f4,f5)索引，起到了 过滤，排序和覆盖 三个作用。</p><h3 id="字段-“不等于”-和-“排序”-查询"><a href="#字段-“不等于”-和-“排序”-查询" class="headerlink" title="字段 “不等于” 和 “排序” 查询"></a>字段 “不等于” 和 “排序” 查询</h3><p>形如:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM `tabel1` WHERE `f1` &gt; 15 AND `f2` = <span class="string">"abc"</span> ORDER BY `f3`</span><br></pre></td></tr></table></figure></p><p>此时，需要根据实际数据情况，选择建立 (f2,f1)索引 或 (f2,f3)索引</p><p>形如:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM `tabel1` WHERE `f1` &gt; 15 ORDER BY `f3`</span><br></pre></td></tr></table></figure></p><p>此时，只可能一个字段使用到索引，要么使用 (f1)索引，要么使用 (f2)索引，这要依据集体的数据情况，一般情况下会使用过滤索引，也就是 (f1)索引。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;索引建立技巧&quot;&gt;&lt;a href=&quot;#索引建立技巧&quot; class=&quot;headerlink&quot; title=&quot;索引建立技巧&quot;&gt;&lt;/a&gt;索引建立技巧&lt;/h2&gt;&lt;h3 id=&quot;单个字段-“等于”-查询&quot;&gt;&lt;a href=&quot;#单个字段-“等于”-查询&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="MySQL" scheme="http://luckymartinlee.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Hadoop从入门到放弃(二) -- HDFS</title>
    <link href="http://luckymartinlee.github.io/2018/05/19/hadoop-1-2/"/>
    <id>http://luckymartinlee.github.io/2018/05/19/hadoop-1-2/</id>
    <published>2018-05-19T07:15:45.000Z</published>
    <updated>2020-12-07T12:52:08.189Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Git 分支策略</title>
    <link href="http://luckymartinlee.github.io/2018/04/28/git-1-1/"/>
    <id>http://luckymartinlee.github.io/2018/04/28/git-1-1/</id>
    <published>2018-04-28T02:46:43.000Z</published>
    <updated>2018-05-19T02:45:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常驻分支（主分支）"><a href="#常驻分支（主分支）" class="headerlink" title="常驻分支（主分支）"></a>常驻分支（主分支）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">master 分支</span><br><span class="line">develop 分支</span><br></pre></td></tr></table></figure><h3 id="master-分支"><a href="#master-分支" class="headerlink" title="master 分支"></a>master 分支</h3><p>即是 Git 默认主分支，只用来发布重大版本，是生产环境出于准备就绪状态的最新源码分支。需要对此分支进行严格的控制，可以为每次 master 分支的提交都挂一个钩子脚本，向生产环境自动化构建并发布我们的软件产品。</p><h3 id="develop-分支"><a href="#develop-分支" class="headerlink" title="develop 分支"></a>develop 分支</h3><p>develop 分支作为日常开发分支，可以理解为准备下一次发布的，开发人员最后一次提交的源码分支，这个分支也叫做 集成分支，此分支也作为每日构建（nightly build）自动化任务的源码分支</p><h2 id="临时分支（支持型分支）"><a href="#临时分支（支持型分支）" class="headerlink" title="临时分支（支持型分支）"></a>临时分支（支持型分支）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">feature 功能开发分支（也叫 topic 分支）</span><br><span class="line">release 预发布分支</span><br><span class="line">hotfix 修补 issue 分支</span><br></pre></td></tr></table></figure><p>这些分支是为了准备发布新产品，开发新的功能特性，快速或者紧急修复上线等任务而设立的分支，这些分支都是临时的，使命完成后，都应该删除。</p><h3 id="release-分支"><a href="#release-分支" class="headerlink" title="release 分支"></a>release 分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">派生自：develop 分支</span><br><span class="line">需要合并回：develop 或者 master 分支</span><br><span class="line">分支命名规范：release-版本号</span><br></pre></td></tr></table></figure><p>release 分支派生自 develop 分支。假设，当前的生产环境发布的版本（ mster 分支）是 1.1，我们确定新的版本号为 1.2 。通过下面命令派生一个新的 release 分支并以新的版本号为其命名：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b release-1.2 develop</span><br><span class="line">$ git commit -a -m <span class="string">"Bumped version number to 1.2"</span></span><br></pre></td></tr></table></figure></p><p>这个新的 release 分支，从创建到发布出去会存在一段时间，在此期间，可能会有issue修复（bug 修复直接在 release 分支上进行）分支，完成后并入 develop 分支，并放入下一次发布。<br>release 分支真正发布成功后，还有下面的事要做：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// release 分支合并到master</span><br><span class="line">$ git checkout master</span><br><span class="line">$ git merge --no-ff release-1.2</span><br><span class="line">// 在 master 分支上的打一个 tag，作为标签以便作为版本历史的参考</span><br><span class="line">$ git tag -a 1.2</span><br><span class="line">// release 分支产生的改动合并回 develop，以便后续的发布同样包含对这些 bug 的修复</span><br><span class="line">$ git checkout develop</span><br><span class="line">// -no-ff 标记使得合并操作总是产生一次新的提交，避免所有提交的历史信息混在一起</span><br><span class="line">$ git merge --no-ff release-1.2</span><br><span class="line">// 至此 release 分支使命已经完成，应该删除它</span><br><span class="line">$ git branch -d release-1.2</span><br></pre></td></tr></table></figure></p><h3 id="feature-分支"><a href="#feature-分支" class="headerlink" title="feature 分支"></a>feature 分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">派生自：develop 分支</span><br><span class="line">需要合并回：develop</span><br><span class="line">分支命名规范：feature-功能特性编号</span><br></pre></td></tr></table></figure><p>feature 分支是用来开发即将发布的新的功能特性。feature 分支的生命周期会和新功能特性的开发周期保持同步，但是最终会合并回 develop 分支或被抛弃(功能特性不需要了)。<br>feature 分支通常仅存在于开发者的代码库中，并不出现在 origin 里。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 从 develop 派生出 feature 分支</span><br><span class="line">$ git checkout -b feature-12345 develop</span><br><span class="line">...</span><br><span class="line">// 功能开发完成后，合并回 develop 分支</span><br><span class="line">$ git checkout develop</span><br><span class="line">$ git merge --no-ff myfeature</span><br><span class="line">// feature 分支使命完成，应该删除</span><br><span class="line">$ git branch -d myfeature</span><br><span class="line">$ git push origin develop</span><br></pre></td></tr></table></figure></p><h3 id="hotfix-分支"><a href="#hotfix-分支" class="headerlink" title="hotfix 分支"></a>hotfix 分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">派生自：master 分支</span><br><span class="line">需要合并回：develop 和 master</span><br><span class="line">分支命名规范：hotfix-issue编号</span><br></pre></td></tr></table></figure><p>hotfix 分支 是在实时的生产环境版本出现意外需要快速响应时，从 master 分支相应的 tag 被派生出来。这样做的原因，是为了让团队其中一个人来快速修复生产环境的问题，其他成员可以按工作计划继续工作下去而不受太大影响。<br>假设，当前 master 版本是1.2 ，生产环境出现了较严重的 issue (假设，记录 bug 编号为 10002)，此时就要从 master 分支派生一个 hotfix 分支：<br><code>`</code> bash<br>// 从 master 派生出 hotfix 分支<br>$ git checkout -b hotfix-10002 master<br>…<br>// 修复 bug，提交代码<br>$ git commit -m “Fixed severe production problem”<br>// bug 修复完成后，hotfix 分支需要并回 master 和 develop 分支，以保证接下来的发布也都已经解决了这个 bug<br>$ git checkout master<br>$ git merge –no-ff hotfix-10002<br>// 变更小版本号<br>$ git tag -a 1.2.1<br>$ git checkout develop<br>$ git merge –no-ff hotfix-10002<br>// hotfix 分支使命完成，应该删除<br>$ git branch -d myfeature</p><p>下图形象的总结了以上分支之间的派生关系<br><img src="/post_imgs/git-branch-1.jpg" alt=""></p><p>本文是阅读了<a href="http://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="noopener">A successful Git branching model</a>之后的自我总结。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;常驻分支（主分支）&quot;&gt;&lt;a href=&quot;#常驻分支（主分支）&quot; class=&quot;headerlink&quot; title=&quot;常驻分支（主分支）&quot;&gt;&lt;/a&gt;常驻分支（主分支）&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td
      
    
    </summary>
    
    
      <category term="Git" scheme="http://luckymartinlee.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Hadoop从入门到放弃(一) -- 基础概念</title>
    <link href="http://luckymartinlee.github.io/2018/03/09/hadoop_1-1/"/>
    <id>http://luckymartinlee.github.io/2018/03/09/hadoop_1-1/</id>
    <published>2018-03-09T02:47:04.000Z</published>
    <updated>2020-12-07T12:51:03.015Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Hadoop-是什么"><a href="#Hadoop-是什么" class="headerlink" title="Hadoop 是什么"></a>Hadoop 是什么</h2><p>Hadoop 是一个开源的大数据框架，一个分布式计算的解决方案。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hadoop = HDFS(分布式文件系统) + MapReduce(分布式计算)</span><br></pre></td></tr></table></figure></p><p>HDFS 分布式文件系统: 海量存储是大数据的技术的基础<br>MapReduce 编程模型: 分布式计算是大数据应用的解决方案</p><h2 id="HDFS-概念"><a href="#HDFS-概念" class="headerlink" title="HDFS 概念"></a>HDFS 概念</h2><h3 id="数据块"><a href="#数据块" class="headerlink" title="数据块"></a>数据块</h3><p>HDFS 上面的文件是按照数据块为单元来存储的，其默认大小为 64MB , 我们可以依据自己的情况进行设置，一般我们设置为 128MB, 备份数是3，也是可以修改的。<br>数据块的大小设置，如设置的太小，小文件也会被切割成多个数据块，访问的时候就要查找多个数据块地址，效率比较低，同时 NameNode 存储了太多的数据块信息，对内存消耗比较多，内存压力大。如果数据块设置过大，就会降低数据并行操作的效率，同时如果系统重启，数据块越大，系统重启的时间就越长<br>使用数据块存储的好处有：</p><ol><li>屏蔽了文件的概念，无论 200KB 还是 200PB 的文件都是按照数据块进行存储，简化了存储系统的设计</li><li>数据块方便数据备份，提高数据容错能力</li></ol><h3 id="NameNode"><a href="#NameNode" class="headerlink" title="NameNode"></a>NameNode</h3><p>NameNode 相当于 master - slave 体系中的 master , 他的职责有：</p><ol><li>管理文件系统的命名空间</li><li>存放文件元数据</li><li>维护文件系统的所有文件和目录</li><li>维护文件与数据块的映射</li><li>记录每个文件的各个块所在数据节点 DataNode 的信息</li></ol><h3 id="DataNode"><a href="#DataNode" class="headerlink" title="DataNode"></a>DataNode</h3><p>DataNode 是 HDFS 文件系统的工作节点，负责存储和检索数据块，向 NameNode 更新所存储块的列表</p><h3 id="HDFS-优-缺点"><a href="#HDFS-优-缺点" class="headerlink" title="HDFS 优/缺点"></a>HDFS 优/缺点</h3><p>优点：</p><ol><li>适合大文件存储，支持 TB、PB 级别数据存储，支持副本策略</li><li>HDFS 可以构建在廉价的普通机器上，具备容错和恢复机制</li><li>支持流逝数据访问，一次写入多次读取效率高<br>缺点:</li><li>不适合大量小文件存储</li><li>不适合并发写入，不支持文件随机修改</li><li>不适合随机度等低延时的访问方式</li></ol><h3 id="HDFS-写流程"><a href="#HDFS-写流程" class="headerlink" title="HDFS 写流程"></a>HDFS 写流程</h3><p><img src="/post_imgs/hdfs_write_process.jpg" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. Client 向 NameNode 发出写请求，表明要将 data 写入到集群当中。</span><br><span class="line">2. NameNode 中存储了集群中所有 DataNode 信息，收到 Client 请求后，就将可用的 DataNode 信息发送给Client</span><br><span class="line">3. Client 依据收到 NameNode 的信息，先将数据进行分块，如分成两块。然后将 数据块1 和 从NameNode接收到的 DataNode所有节点信息，都发送给 DataNode-1</span><br><span class="line">4. DataNode-1 接收到信息后，先将 数据块1 进行保存，在依据接收的DataNode节点集群信息，将 数据块1 备份到 DataNode-2 和 DataNode-3。 当 DataNode-1，DataNode-2，DataNode-3 完成 数据块1 存储之后，反馈给 NameNode</span><br><span class="line">5. NameNode 收到 DataNode 发来的反馈信息后，更新自己的 DataNode 元数据信息列表。然后告诉 Client 数据块1 已经存储好了，可以存储后面的数据块了</span><br><span class="line">6. Client 收到 NameNode 信息后，开始重复 数据块1的存储步骤，存储 数据块2，至此 HDFS 写数据流程结束</span><br></pre></td></tr></table></figure></p><h3 id="HDFS-写流程-1"><a href="#HDFS-写流程-1" class="headerlink" title="HDFS 写流程"></a>HDFS 写流程</h3><p><img src="/post_imgs/hdfs_read_process.jpg" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. Client 向 NameNode 发出读请求，表明要从集群中读取文件 data。</span><br><span class="line">2. NameNode 收到 Client 请求后，就将存储了 data 文件数据块的DataNode 节点信息发送给 Client，如上图，DataNode-1 存储了 数据块1，DataNode-2 存储了 数据块2，DataNode-3 存储了 数据块1 和 数据块2</span><br><span class="line">3. Client 依据收到 NameNode 的信息，先从 DataNode-1 读取 数据块1 ，然后再从 DataNode-2 读取 数据块2，如果 DataNode-2 宕机，Client 就会向 DataNode-3 读取 数据块2， 至此 HDFS 读数据流程结束</span><br></pre></td></tr></table></figure></p><h3 id="HDFS-常用命令"><a href="#HDFS-常用命令" class="headerlink" title="HDFS 常用命令"></a>HDFS 常用命令</h3><ol><li>类Linux系统命令: ls, cat, mkdir, rm, chomd, chown, …</li><li>HDFS文件交互命令: copyFromLocal, copyToLocal, get, put</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Hadoop-是什么&quot;&gt;&lt;a href=&quot;#Hadoop-是什么&quot; class=&quot;headerlink&quot; title=&quot;Hadoop 是什么&quot;&gt;&lt;/a&gt;Hadoop 是什么&lt;/h2&gt;&lt;p&gt;Hadoop 是一个开源的大数据框架，一个分布式计算的解决方案。&lt;br&gt;&lt;f
      
    
    </summary>
    
    
      <category term="Hadoop" scheme="http://luckymartinlee.github.io/tags/Hadoop/"/>
    
      <category term="大数据" scheme="http://luckymartinlee.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch从入门到放弃(三) -- 疑难配置详解</title>
    <link href="http://luckymartinlee.github.io/2018/02/01/elasticsearch_1-3/"/>
    <id>http://luckymartinlee.github.io/2018/02/01/elasticsearch_1-3/</id>
    <published>2018-02-01T07:41:28.000Z</published>
    <updated>2020-12-17T03:39:20.185Z</updated>
    
    <content type="html"><![CDATA[<h2 id="elasticsearch-yml"><a href="#elasticsearch-yml" class="headerlink" title="elasticsearch.yml"></a>elasticsearch.yml</h2><p>node.master: true<br>指定该节点是否有资格被选举成为node，默认是true，es是默认集群中的第一台机器为master，如果这台机挂了就会重新选举master</p><p>node.data: true<br>指定该节点是否存储索引数据，默认为true。</p><p>path.data: /path/to/data<br>设置索引数据的存储路径，默认是es根目录下的data文件夹，可以设置多个存储路径，用逗号隔开，例：<br>path.data: /path/to/data1,/path/to/data2<br>但是我们同一个分片的数据会放在同一个路径</p><p>index.number_of_shards: 5<br>设置默认索引分片个数，默认为5片。分片个数是索引创建后一次生成的,后续不可更改设置</p><p>index.number_of_replicas: 1<br>设置默认索引每个分片副本个数，默认每个分片1个副本，如分片数为5，那么副本分片也为5个，总共10个分片。可以通过API去实时修改设置的。（集群健康度可用 curl ‘localhost:9200/_cat/health?v’ 查看， 分为绿色、黄色或红色。绿色代表一切正常，集群功能齐全，黄色意味着所有的数据都是可用的，但是某些副本没有被分配，红色则代表因为某些原因，某些数据不可用)</p><p>bootstrap.mlockall: true<br>设置为true来锁住内存。因为当jvm开始swapping时es的效率 会降低，所以要保证它不swap，可以把ES_MIN_MEM和ES_MAX_MEM两个环境变量设置成同一个值，并且保证机器有足够的内存分配给es。 同时也要允许elasticsearch的进程可以锁住内存，linux下可以通过ulimit -l unlimited命令。</p><p>network.bind_host: 192.168.0.1<br>设置该节点绑定的ip地址，可以绑定多个ip地址，允许哪些ip可以访问这个这节，包括外部访问和es集群内节点互相访问，可以是ipv4或ipv6的，默认为0.0.0.0。<br>network.bind_host: [“192.168.0.1”,”10.210.32.xx”]<br>代表集群节点之间 使用 192.168.0.1 ip交换数据，同时 允许所有10.210.32.xx IP段 访问集群</p><p>network.publish_host: 192.168.0.1<br>设置es节点之间交互的ip地址，如果不设置它会自动判断，值必须是个真实的ip地址。</p><p>network.host: 192.168.0.1<br>这个参数是用来同时设置bind_host和publish_host上面两个参数，项目局域网内可以使用者一个参数代替上面两个参数配置，但如涉及到内网，外网都要访问es集群，就需要单独设置上面两个参数</p><p>transport.tcp.port: 9300<br>设置节点间交互的tcp端口，默认是9300。</p><p>transport.tcp.compress: true<br>设置在节点间传输数据时是否压缩，默认为false，不压缩</p><p>http.max_content_length:100mb<br>设置请求返回内容的最大容量,默认100mb。</p><p>discovery.zen.minimum_master_nodes: 1<br>设置在选举Master节点时需要参与的最少的候选主节点数，默认为1.<br>这个配置就是告诉 Elasticsearch 当没有足够 master 候选节点的时候，就不要进行 master 节点选举，等 master 候选节点足够了才进行选举。<br>如果使用默认值，则当网络不稳定时有可能会出现脑裂(一种两个主节点同时存在于一个集群的现象)。合理的数值为(master_eligible_nodes/2)+1，其中master_eligible_nodes表示集群中的候选主节点数。</p><p>discovery.zen.ping.timeout: 3s<br>设置在集群中自动发现其他节点时ping连接的超时时间，默认为3秒。在较差的网络环境下需要设置得大一点，防止因误判该节点的存活状态而导致分片的转移。</p><p>gateway.recover_after_nodes: 8<br>设置整个集群提供服务之前你希望有多少个节点在线。看下面的例子：</p><p>想象一下假设你有 10 个节点，每个节点只保存一个分片，这些分片有 5 个主分片和5 个副本分片的索引。有时你需要为整个集群做离线维护（比如，为了安装一个新的驱动程序）， 当你重启你的集群，恰巧出现了 5 个节点已经启动，还有 5 个还没启动的场景。<br>假设其它 5 个节点出问题，或者他们根本没有收到立即重启的命令。不管什么原因，你有 5 个节点在线上，这五个节点会相互通信，选出一个 master，从而形成一个集群。 他们注意到数据不再均匀分布，因为有 5 个节点在集群中丢失了，所以他们之间会立即启动分片复制。<br>最后，你的其它 5 个节点打开加入了集群。这些节点会发现 它们 的数据正在被复制到其他节点，所以他们删除本地数据（因为这份数据要么是多余的，要么是过时的）。 然后整个集群重新进行平衡，因为集群的大小已经从 5 变成了 10。<br>在整个过程中，你的节点会消耗磁盘和网络带宽，来回移动数据，因为没有更好的办法。对于有 TB 数据的大集群, 这种无用的数据传输需要 很长时间 。如果等待所有的节点重启好了，整个集群再上线，所有的本地的数据都不需要移动。</p><p>这种情况下，我们设置为 8，这意味着至少要有 8 个节点，该集群才可用。</p><p>gateway.expected_nodes: 10<br>设置这个集群中节点的数量，默认为2</p><p>gateway.recover_after_time: 5m<br>设置初始化数据恢复进程的超时时间，默认是5分钟</p><p>以上三个配置参数，告诉ES 集群：<br>等待集群至少存在 8 个节点<br>等待 5 分钟，或者10 个节点上线后，才进行数据恢复，这取决于哪个条件先达到<br>这样集群重启的时候避免过多的分片交换。这可能会让数据恢复从数个小时缩短为几秒钟。</p><p>discovery.zen.ping.unicast.hosts: [“host1”, “host2:port”, “host3[portX-portY]”]<br>设置集群中master节点的初始列表，可以通过这些节点来自动发现新加入集群的节点。<br>没有任何网络配置，Elasticsearch将绑定到可用的回环地址，并将扫描端口9300到9305以尝试连接到在同一服务器上运行的其他节点。 这提供了自动群集体验，无需进行任何配置。</p><h2 id="jvm-heap-size-配置"><a href="#jvm-heap-size-配置" class="headerlink" title="jvm heap size 配置"></a>jvm heap size 配置</h2><p>一般在运行elasticsearch 的时候最小需要是内存是1G，少于1G我们会经常启动不了。<br>-Xms1g  # 最小值为1G<br>-Xmx1g  # 最大值为1G<br>对于这个值的设置，官方为了适应不同的java版本,特做了一些适应配置<br>-Xms1g   不受版本影响，默认<br>8:-Xmx2g   只适应java8版本<br>8-:-Xmx2g  适应java8及以上版本<br>8-9:-Xmx2g  适应java8-java9版本</p><p>官方文档写到：以往经验得出，</p><ol><li>最大值和最小值设置为一样的值，否则在系统使用的时候会因jvm值变化而导致服务暂停</li><li>过多的内存，会导致用于缓存的内存越多，最终导致回收内存的时间也加长</li><li>设置的内存不要超过物理内存的50%，以保证有足够的内存留给操作系统</li><li>不要将内存设置超过32GB</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;elasticsearch-yml&quot;&gt;&lt;a href=&quot;#elasticsearch-yml&quot; class=&quot;headerlink&quot; title=&quot;elasticsearch.yml&quot;&gt;&lt;/a&gt;elasticsearch.yml&lt;/h2&gt;&lt;p&gt;node.maste
      
    
    </summary>
    
    
      <category term="Elasticsearch" scheme="http://luckymartinlee.github.io/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch从入门到放弃(二) -- 零基础环境搭建</title>
    <link href="http://luckymartinlee.github.io/2018/01/28/elasticsearch_1-2/"/>
    <id>http://luckymartinlee.github.io/2018/01/28/elasticsearch_1-2/</id>
    <published>2018-01-28T01:33:35.000Z</published>
    <updated>2020-12-17T03:39:21.638Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要讲述 Linux 虚拟机环境下 Elasticsearch 5.5 版本的安装。安装 Elasticsearch 之前，请确保你的机器 Java 8 环境已经搭建好，保证环境变量 JAVA_HOME 设置正确。如你还没有安装好 JAVA 8 环境，请参考<a href="/2017/11/04/java_1-1/">linux系统中JAVA环境搭建</a></p><h4 id="下载并解压安装包"><a href="#下载并解压安装包" class="headerlink" title="下载并解压安装包"></a>下载并解压安装包</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-5.5.0.zip</span><br><span class="line">$ unzip elasticsearch-5.5.0.zip</span><br><span class="line">$ <span class="built_in">cd</span> elasticsearch-5.5.0/</span><br></pre></td></tr></table></figure><h4 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h4><p>Elasticsearch 默认只允许本机访问，远程访问，需要修改 config/elasticsearch.yml,<br>改为运行所有人访问 0.0.0.0（生产环境，切不可这样改，可以指定特定 ip 访问 Elasticsearch）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ vim config/elasticsearch.yml</span><br><span class="line"></span><br><span class="line"><span class="comment">#network.host: 192.168.0.1</span></span><br><span class="line">network.host: 0.0.0.0</span><br></pre></td></tr></table></figure></p><h4 id="启动程序"><a href="#启动程序" class="headerlink" title="启动程序"></a>启动程序</h4><p>直接运行 bin 目录下的 elasticsearch<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./bin/elasticsearch</span><br></pre></td></tr></table></figure></p><p>此过程中，可能会报出以下错误<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max virtual memory areas vm.maxmapcount [65530] is too low</span><br></pre></td></tr></table></figure></p><p>此时，切换到管理员用户，运行下面的命令即可<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sysctl -w vm.max_map_count=262144</span></span><br></pre></td></tr></table></figure></p><p>重新运行 elasticsearch 即可，这时候访问 9200 端口，得到如下信息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ curl http://127.0.0.1:9200</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span> : <span class="string">"uA7Io-i"</span>, <span class="comment"># node 名称</span></span><br><span class="line">  <span class="string">"cluster_name"</span> : <span class="string">"elasticsearch"</span>, <span class="comment"># 集群名称 </span></span><br><span class="line">  <span class="string">"cluster_uuid"</span> : <span class="string">"f7y_hJefSw-kQFN-zt-3Cw"</span>, <span class="comment"># 集群唯一 id</span></span><br><span class="line">  <span class="string">"version"</span> : &#123;</span><br><span class="line">    <span class="string">"number"</span> : <span class="string">"5.5.0"</span>, <span class="comment"># Elasticsearch 版本号</span></span><br><span class="line">    <span class="string">"build_hash"</span> : <span class="string">"260387d"</span>,</span><br><span class="line">    <span class="string">"build_date"</span> : <span class="string">"2017-06-30T23:16:05.735Z"</span>,</span><br><span class="line">    <span class="string">"build_snapshot"</span> : <span class="literal">false</span>,</span><br><span class="line">    <span class="string">"lucene_version"</span> : <span class="string">"6.6.0"</span> <span class="comment"># 依赖的 Lucene 版本号</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"tagline"</span> : <span class="string">"You Know, for Search"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>到这里说明你的 Elasticsearch 已经安装成功了，按下 Ctrl + C，Elasticsearch 就会停止运行。 想要后台运行 Elasticsearch，输入下面命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./bin/elasticsearch -d</span><br></pre></td></tr></table></figure></p><p>此时想要停止 Elasticsearch ，想要先找到 Elasticsearch 进程，然后 kill 。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ps -ef |grep elasticsearch</span><br><span class="line"></span><br><span class="line">martin    3035  2200  0 Apr19 ?        00:04:29 /usr/bin/java -Xms2g -Xmx2g -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=75 -XX:+UseCMSInitiatingOccupancyOnly -XX:+AlwaysPreTouch -server -Xss1m -Djava.awt.headless=<span class="literal">true</span> -Dfile.encoding=UTF-8 -Djna.nosys=<span class="literal">true</span> -Djdk.io.permissionsUseCanonicalPath=<span class="literal">true</span> -Dio.netty.noUnsafe=<span class="literal">true</span> -Dio.netty.noKeySetOptimization=<span class="literal">true</span> -Dio.netty.recycler.maxCapacityPerThread=0 -Dlog4j.shutdownHookEnabled=<span class="literal">false</span> -Dlog4j2.disable.jmx=<span class="literal">true</span> -Dlog4j.skipJansi=<span class="literal">true</span> -XX:+HeapDumpOnOutOfMemoryError -Des.path.home=/home/marting/elasticsearch-5.5.0 -cp /home/martin/elasticsearch-5.5.0/lib/* org.elasticsearch.bootstrap.Elasticsearch</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">kill</span> -2 3035</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文主要讲述 Linux 虚拟机环境下 Elasticsearch 5.5 版本的安装。安装 Elasticsearch 之前，请确保你的机器 Java 8 环境已经搭建好，保证环境变量 JAVA_HOME 设置正确。如你还没有安装好 JAVA 8 环境，请参考&lt;a hre
      
    
    </summary>
    
    
      <category term="Elasticsearch" scheme="http://luckymartinlee.github.io/tags/Elasticsearch/"/>
    
  </entry>
  
</feed>
